<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[从输入 URL 到页面加载完成的过程中都发生了什么事情？]]></title>
      <url>https://blog.tiy.xyz/posts/2018/3141220995/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>“从输入 URL 到页面加载完成的过程中都发生了什么事情？” 这个问题流传至今，千人千答，但又经久不衰。随着时代的前进，各种“事情”都在变化着，很难有一个标准的答案。但是，作为一名 Web 开发者，我认为有必要了解并总结，这期间到底发生了什么，作为自身知识体系的结构纵贯线。</p>
<a id="more"></a>
<h2><span id="目录">目录</span></h2>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E5%BA%8F%E6%9B%B2">序曲</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E8%BE%93%E5%85%A5">浏览器解析输入</a></li>
<li><a href="#dns-%E6%9F%A5%E8%AF%A2">DNS 查询</a></li>
<li><a href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5">建立连接</a></li>
<li><a href="#%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%EF%BC%88request%EF%BC%89">发送 HTTP 请求数据（Request）</a>
<ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B">请求数据示例</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">请求数据结构</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%A1%88">请求方案</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E7%89%B9%E7%82%B9">请求特点</a></li>
</ul>
</li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82">服务器处理请求</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%EF%BC%88response%EF%BC%89">接收服务器响应数据（Response）</a>
<ul>
<li><a href="#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B">响应数据示例</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">响应数据结构</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%9E%90%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE">分析响应数据</a>
<ul>
<li><a href="#%E5%BB%B6%E6%97%B6%E5%88%86%E6%9E%90">延时分析</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2">解析并渲染页面</a>
<ul>
<li><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B">主流程</a>
<ul>
<li><a href="#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E%EF%BC%88rendering-engine%EF%BC%89">呈现引擎（Rendering Engine）</a></li>
<li><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B">主流程示例</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%EF%BC%88parsing%EF%BC%89">解析（Parsing）</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88lexical-analysis%EF%BC%89">词法分析（Lexical Analysis）</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88syntax-aalysis%EF%BC%89">语法分析（Syntax Aalysis）</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E8%BD%AC%E6%8D%A2">迭代转换</a></li>
<li><a href="#%E7%BF%BB%E8%AF%91%EF%BC%88translation%EF%BC%89">翻译（Translation）</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90-html%EF%BC%88html-parser%EF%BC%89">解析 HTML（HTML Parser）</a>
<ul>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90">语法分析</a></li>
<li><a href="#%E7%94%9F%E6%88%90-dom">生成 DOM</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%E6%A0%B7%E5%BC%8F%EF%BC%88style%EF%BC%89">解析样式（Style）</a>
<ul>
<li><a href="#%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%9D%A5%E6%BA%90">样式的来源</a></li>
<li><a href="#%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E6%9D%A5%E6%BA%90">样式表的来源</a></li>
<li><a href="#css-%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88css-parser%EF%BC%89">CSS 解析器（CSS parser）</a></li>
<li><a href="#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97">样式计算</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%E8%84%9A%E6%9C%AC%EF%BC%88script%EF%BC%89">解析脚本（Script）</a></li>
<li><a href="#%E5%86%85%E5%B5%8C%E8%84%9A%E6%9C%AC">内嵌脚本</a></li>
<li><a href="#%E5%A4%96%E9%93%BE%E8%84%9A%E6%9C%AC">外链脚本</a></li>
<li><a href="#%E4%BC%98%E5%8C%96">优化</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90">解析其他资源</a></li>
<li><a href="#%E9%A2%84%E8%A7%A3%E6%9E%90">预解析</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%E5%AE%8C%E6%AF%95">解析完毕</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E5%91%88%E7%8E%B0%E6%A0%91%EF%BC%88render-tree%EF%BC%89">构建呈现树（Render Tree）</a>
<ul>
<li><a href="#%E5%91%88%E7%8E%B0%E6%A0%91%E5%92%8C-dom-%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB">呈现树和 DOM 树的关系</a></li>
<li><a href="#%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%A4%84%E7%90%86">渐进式处理</a></li>
</ul>
</li>
<li><a href="#%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89">布局（Layout）</a></li>
<li><a href="#%E7%BB%98%E5%88%B6%EF%BC%88paint%EF%BC%89">绘制（Paint）</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">动态变化</a></li>
<li><a href="#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event-loop%EF%BC%89">呈现引擎和事件循环（Event Loop）</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">[参考资料]</a></li>
</ul>
<h2><span id="序曲">序曲</span></h2>
<p>“从输入 URL 到页面加载完成的过程中都发生了什么事情？” 这个问题流传至今，千人千答，但又经久不衰。随着时代的前进，各种“事情”都在变化着，很难有一个标准的答案。</p>
<p>但是，作为一名 Web 开发者，我认为有必要了解并总结，这期间到底发生了什么，作为自身知识体系的结构纵贯线。</p>
<p>“事情”过程涉及的知识广度与深度可尽情拓展，不同的开发人员可能有着不同的理解和答案。本文站在 Web 前端开发者 的角度，探索并总结了这些“事情”。这是站在许多巨人的肩膀上，借鉴、吸收、转换的结果。希望看到本篇的你，若有所思，共同交流。</p>
<h2><span id="浏览器解析输入">浏览器解析输入</span></h2>
<p><code>GUI</code> 将输入事件传递到了浏览器中，在这过程中，浏览器可能会做一些预处理，比如 <code>Chrome</code> 会根据历史统计来预估所输入字符对应的网站，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「 www.baidu.com 」，因此就会在输入回车前就马上开始建立 <code>TCP</code> 链接甚至渲染了，这里面还有很多其它策略。</p>
<blockquote>
<p>深入了解： <a href="//aosabook.org/en/posa/high-performance-networking-in-chrome.html">High Performance Networking in Chrome</a></p>
</blockquote>
<p>接着是输入 <code>URL</code> 后的「回车」，这时浏览器会对 <code>URL</code> 进行检查，首先判断协议，如果是 <code>http(s)</code> 就按照 <code>Web</code> 来处理，另外还会对 <code>URL</code> 进行安全检查，然后直接调用浏览器内核中的对应方法，比如 <code>WebView</code> 中的 <code>loadUrl</code> 方法。</p>
<h2><span id="dns-查询">DNS 查询</span></h2>
<p><code>DNS</code> 查询是基于 <code>UDP</code> 来实现的</p>
<p><code>DNS</code> 查询顺序如下，若其中一步成功则直接跳到建立连接部分：</p>
<ol>
<li>浏览器自身缓存：缓存时间（TTL）不定，由浏览器控制</li>
<li>操作系统缓存：系统 DNS 查询调用</li>
<li>路由器缓存</li>
<li>ISP 缓存</li>
<li>递归搜索：向域名服务器（<code>NS</code>）发送请求，直至根域</li>
</ol>
<h2><span id="建立连接">建立连接</span></h2>
<ul>
<li>
<p>TCP 三次握手（Three-way handshake）：<code>SYN &gt; SYN-ACK &gt; ACK</code></p>
</li>
<li>
<p>目的：确认双方互联网络的连通性，不至于浪费资源。主要流程如下：</p>
<ol>
<li>发送方：SYN（Synchronize）</li>
<li>接收方：SYN/ACK（Acknowledgement）- 确认信息传达</li>
<li>发送方：ACK - 确认接收方在线可收消息，握手结束</li>
<li>Accept</li>
</ol>
</li>
<li>
<p>图示：</p>
<p><img src="img/tcp_three_way_handshake.png" alt="TCP 三次握手" title="TCP 三次握手">
TCP 三次握手（Three-way handshake）</p>
</li>
<li>
<p>问题：每次 TCP 连接的建立过程都需要增加往返延时，受到客户端与服务端的距离、路由路径等因素影响，建立过程延时与发送的数据量无关。（因此需要适当减少连接数）</p>
</li>
<li>
<p>建立完毕：如果是 <code>HTTPS</code> 连接，则额外增加包含 <strong>2次</strong> 往返延时的 <code>SSL</code> 握手。如果 <code>SSL</code> 会话已经存在缓存，则只需要 <strong>1次</strong> 往返。</p>
</li>
</ul>
<h2><span id="发送-http-请求数据request">发送 HTTP 请求数据（Request）</span></h2>
<h3><span id="请求数据示例">请求数据示例</span></h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"></span><br><span class="line"><span class="attribute">Host</span>: www.baidu.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">User-Agent</span>: AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Cookie</span>: foo=1; bar=2</span><br></pre></td></tr></table></figure>
<h3><span id="请求数据结构">请求数据结构</span></h3>
<ol>
<li>报文首部（<code>GET /index HTTP/1.1</code>）
<ul>
<li>方法</li>
<li>URL</li>
<li>HTTP 版本</li>
</ul>
</li>
<li>空行（CR+LF）</li>
<li>报文主体</li>
</ol>
<h3><span id="请求方案">请求方案</span></h3>
<p>在浏览器内核中会先查看缓存，然后设置 <code>UA</code> 等 <code>HTTP</code> 信息，接着调用不同平台下网络请求的方法。</p>
<blockquote>
<p>注意：浏览器和浏览器内核是不同的概念，浏览器指的是 Chrome、Firefox，而浏览器内核则是 Blink、Gecko，浏览器内核只负责渲染，GUI 及网络连接等跨平台工作则是浏览器实现的</p>
</blockquote>
<h3><span id="请求特点">请求特点</span></h3>
<ul>
<li>
<p><code>HTTP</code> 请求内容是 <strong>纯文本</strong> 格式的，所以在 <code>TCP</code> 的数据段中可以直接分析 <code>HTTP</code> 的文本</p>
</li>
<li>
<p><code>HTTP</code> 是无连接、无状态的，即 <code>HTTP</code> 在传输完成后就会断开，并且下一次登录时不会记录上次的登录状态</p>
</li>
<li>
<p>从 <code>HTTP/1.1</code> 开始才支持持久连接，即通信一次以后连接不中断：</p>
<blockquote>
<p>正常为请求一次响应一次: 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3
若采用持久连接请求管线化方式： 请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>
</blockquote>
<p>使用管线化的条件：</p>
<ul>
<li>服务端需要支持管线化</li>
<li>只有 <code>GET</code> 和 <code>HEAD</code> 请求方式可以进行管线化，<code>POST</code> 请求有所限制</li>
<li>管线化不会影响响应到来的顺序</li>
</ul>
</li>
<li>
<p>请求体中的换行符：</p>
<ul>
<li><code>Dos</code> / <code>Windows</code>：<code>CR/LF</code></li>
<li><code>UNIX</code> / <code>Linux</code>：<code>LF</code>（Line Feed）</li>
<li><code>MAC OS</code>：<code>CR</code>（Carriage Return）</li>
</ul>
</li>
</ul>
<h2><span id="服务器处理请求">服务器处理请求</span></h2>
<p>服务器接收请求数据后，根据请求类型将请求交付给不同的处理模块进行处理（读取、存储、更改等）。
处理完毕后，返回相应的处理结果（文本/图像/数据流等）。</p>
<h2><span id="接收服务器响应数据response">接收服务器响应数据（Response）</span></h2>
<h3><span id="响应数据示例">响应数据示例</span></h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line"><span class="attribute">Cache-Control</span>: private</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Date</span>: Tue, 10 Jul 2018 07:10:18 GMT</span><br><span class="line"><span class="attribute">Expires</span>: Tue, 10 Jul 2018 07:10:18 GMT</span><br><span class="line"><span class="attribute">Server</span>: BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span>: BD_HOME=0; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span>: FOO=bar; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span>: max-age=172800</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span>: IE=Edge,chrome=1</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>
<h3><span id="响应数据结构">响应数据结构</span></h3>
<ol>
<li>报文首部（<code>HTTP/1.1 200 OK</code>）
<ul>
<li>HTTP 版本</li>
<li>响应状态码</li>
<li>状态码信息</li>
</ul>
</li>
<li>空行（CR+LF）</li>
<li>报文主体</li>
</ol>
<h2><span id="分析响应数据">分析响应数据</span></h2>
<ul>
<li>如果响应中包含 HTTP 重定向，则需要额外重新发起以上整个请求往返循环过程。</li>
<li>如果响应中包含 <code>Content-Encoding</code> 头的压缩算法，浏览器将根据相应的算法进行内容解码，还原实际数据</li>
<li>缓存：<code>Cache-Control</code> 响应头告知浏览器内容缓存时效</li>
<li>Cookie：<code>Set-Cookie</code> 响应头告知浏览器设置相应的客户端 <code>Cookie</code></li>
<li>内容类型：<code>Content-Type</code> 响应头告知浏览器响应数据的 <code>MIME</code> 类型，浏览器根据内部设置，交付给不同的解析器去解析数据（解析或下载等）。响应的资源一般是指 <code>HTML</code> 文档，也可以是 <code>PDF</code>、图片或其他的类型。</li>
</ul>
<h3><span id="延时分析">延时分析</span></h3>
<p>以最糟糕的典型宽带连接为例（忽略本地缓存）：</p>
<ol>
<li>DNS 解析</li>
<li>TCP 握手 (1次 RTT)</li>
<li>SSL 握手 (2次 RTTs)</li>
<li>发送请求到服务器</li>
<li>服务器处理</li>
<li>服务器发送相应到客户端</li>
</ol>
<p>另外：</p>
<ul>
<li>如果服务端响应内容不符合最初的 TCP 拥塞窗口（Congestion Window）（4-15KB），则需要更多额外的往返操作延时</li>
<li>如果在建立 SSL 连接过程中，证书不存在，或者需要在线证书状态检查（OCSP）（Online Certificate Status Check），都需要额外建立一次 TCP 连接，这会增加上千毫秒的额外延时</li>
</ul>
<h2><span id="解析并渲染页面">解析并渲染页面</span></h2>
<blockquote>
<p>深入了解：<a href="//https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">How Browsers Work</a></p>
</blockquote>
<h3><span id="主流程">主流程</span></h3>
<p>流程图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 解析 HTML 构建 DOM 树</span><br><span class="line">op2=&gt;operation: 创建 结构树（框架树/呈现树）</span><br><span class="line">op3=&gt;operation: 渲染树 布局（重排）</span><br><span class="line">op4=&gt;operation: 渲染树 绘制</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;e</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<ul>
<li>
<p>构建渲染树（Render Tree）：根据 DOM 和 CSSOM 树渲染，不可见元素不被会渲染</p>
<p><img src="img/render_tree_construction.png" alt="渲染树（Render Tree）构建" title="渲染树（Render Tree）构建">
构建渲染树（Render Tree）</p>
</li>
<li>
<p>布局（Layout）：CPU 根据渲染树布局计算元素的具体位置和大小，转换成绝对像素，并且根据样式，分割成多个独立的渲染层（Layers），将每一层对应到位图中</p>
</li>
<li>
<p>绘制（Paint）：GPU 根据每个渲染层（Layers）的位图绘制每个点，即像素填充,并且将所以渲染层缓存，如果下次页面变动但是渲染层没变就不会触发重绘。</p>
</li>
<li>
<p>层级合成（Compositing）：顾名思义，即处理多层渲染层之间的关系，将其合成为一个完整的页面。</p>
</li>
</ul>
<h4><span id="呈现引擎rendering-engine">呈现引擎（Rendering Engine）</span></h4>
<p>负责显示请求的内容。如果请求的内容是 <code>HTML</code>，它就负责解析 <code>HTML</code> 和 <code>CSS</code> 内容，并将解析后的内容显示在屏幕上。</p>
<p>默认情况下，呈现引擎可显示 <code>HTML</code> 和 <code>XML</code> 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 <code>PDF</code> 查看器插件就能显示 <code>PDF</code> 文档。</p>
<h4><span id="主流程示例">主流程示例</span></h4>
<ul>
<li>
<p><code>Webkit</code>：Safari / Chrome</p>
<p><img src="img/webkit_flow.png" alt="WebKit 主流程" title="WebKit 呈现引擎主流程">
WebKit 呈现引擎主流程</p>
</li>
<li>
<p><code>Gecko</code>：Firefox</p>
<p><img src="img/gecko_flow.jpg" alt="Gecko 主流程" title="Gecko 呈现引擎主流程">
Gecko 呈现引擎主流程</p>
</li>
</ul>
<h3><span id="解析parsing">解析（Parsing）</span></h3>
<h4><span id="概述">概述</span></h4>
<p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 源代码（Source Code）</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 分析转换（Parsing）</span><br><span class="line">op2=&gt;operation: 解析树（Parse Tree）</span><br><span class="line">op3=&gt;operation: 翻译（Translation）</span><br><span class="line"></span><br><span class="line">e=&gt;end: 机器码（Machine Code）</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;e</span><br></pre></td></tr></table></figure>
<h4><span id="词法分析lexical-analysis">词法分析（Lexical Analysis）</span></h4>
<p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。</p>
<p>词法分析工具：<strong>词法分析器</strong>（有时也称为标记生成器），负责将输入内容分解成一个个有效标记。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p>
<h4><span id="语法分析syntax-aalysis">语法分析（Syntax Aalysis）</span></h4>
<p>语法分析是应用语言的语法规则的过程。</p>
<p>语法分析工具：<strong>解析器</strong>，负责根据语言的语法规则分析文档的结构，从而构建解析树。</p>
<h4><span id="迭代转换">迭代转换</span></h4>
<p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p>
<p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p>
<h4><span id="翻译translation">翻译（Translation）</span></h4>
<p>翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p>
<h4><span id="解析-htmlhtml-parser">解析 HTML（HTML Parser）</span></h4>
<h5><span id="语法分析">语法分析</span></h5>
<p>HTML 无法用常规的自上而下或自下而上的解析器进行解析。
HTML 的特点是：</p>
<ol>
<li>语言的宽容本质。</li>
<li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li>
<li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 <code>document.write</code>，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li>
</ol>
<p>HTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化 和 树构建。</p>
<p>浏览器具有很好的容错机制，会纠正任何无效内容，然后继续工作。</p>
<h5><span id="生成-dom">生成 DOM</span></h5>
<p>解析的结果是 DOM（Document Object Model），代表 HTML 文档与外部 HTML 元素的接口（如 JavaScript）。</p>
<p>HTML 文本示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>DOM 树示例：</p>
<p><img src="img/dom_tree_exp.png" alt="DOM 树生成示例" title="解析 HTML 构建 DOM 树">
解析 HTML 构建 DOM 树</p>
<h4><span id="解析样式style">解析样式（Style）</span></h4>
<h5><span id="样式的来源">样式的来源</span></h5>
<ul>
<li>外部样式表</li>
<li>inline 样式属性及类似内容</li>
<li>HTML 可视化属性（映射到相关的样式规则）（例如 <code>bgcolor</code> 属性）</li>
</ul>
<h5><span id="样式表的来源">样式表的来源</span></h5>
<ol>
<li>浏览器的默认样式表</li>
<li>网页提供的样式表</li>
<li>浏览器用户提供的用户样式表</li>
</ol>
<h5><span id="css-解析器css-parser">CSS 解析器（CSS parser）</span></h5>
<blockquote>
<p>样式表的加载应用虽然不会更改 DOM 树，但可能会影响脚本对文档内容信息获取的结果，因此需要考虑等待样式表并停止文档解析，但并非一致。</p>
</blockquote>
<ul>
<li>Firefox 在样式表加载和解析的过程中，会禁止所有脚本。</li>
<li>而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</li>
</ul>
<p>CSS 语法分析转换：</p>
<p><img src="img/css_parsing.png" alt="CSS 语法分析转换" title="CSS 语法分析转换">
CSS 语法分析转换</p>
<h5><span id="样式计算">样式计算</span></h5>
<p>计算流程：</p>
<ol>
<li>划分结构。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代；</li>
<li>使用规则树计算样式上下文；</li>
<li>处理规则，简化匹配；</li>
<li>按照规则排列层叠顺序，应用属性。</li>
</ol>
<h4><span id="解析脚本script">解析脚本（Script）</span></h4>
<h4><span id="内嵌脚本">内嵌脚本</span></h4>
<p>解析器遇到 <code>&lt;script&gt;</code> 标记时，阻塞 DOM 的构建，立即解析并执行脚本。
文档的解析将停止，直到脚本执行完毕。</p>
<h4><span id="外链脚本">外链脚本</span></h4>
<p>解析器遇到外部引用脚本，那么 DOM 解析过程会停止，发起一个网络请求，直到 <strong>同步</strong> 抓取资源完成后再继续解析 HTML 构建 DOM。</p>
<p>而当前新式浏览器做了优化，此时会继续下载文档并解析，再次遇到脚本引用时，会新增请求，<strong>并行</strong> 下载脚本（浏览器对并行个数有限制）。但是最终的执行顺序是按照 HTML 文档的脚本顺序先后执行的，同样也会阻塞其他资源的下载。</p>
<h4><span id="优化">优化</span></h4>
<p>此模型已经使用了多年，也在 <code>HTML4</code> 和 <code>HTML5</code> 规范中进行了指定。
可以将脚本标注为 <code>defer</code>，这样它就不会停止文档解析，而是等到解析结束才执行。<code>HTML5</code> 增加了一个选项，可将脚本标记为异步（<code>async</code>），以便由其他线程解析和执行。</p>
<h4><span id="解析其他资源">解析其他资源</span></h4>
<p>其他资源，比如图像（<code>img</code>）等内嵌网络资源，并不会阻塞 DOM 的转换，浏览器仅仅发送额外的请求获取资源，然后继续执行后面的操作，不需等待请求返回。让资源返回后，只需把相应的内容插入到 DOM 树中相应位置即可。</p>
<h4><span id="预解析">预解析</span></h4>
<p>WebKit 和 Firefox 都进行了这项优化。
在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。
通过这种方式，资源可以在并行连接上加载，从而提高总体速度。
请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；
预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>
<h3><span id="解析完毕">解析完毕</span></h3>
<p>浏览器会将文档标注为 <strong>交互状态</strong>，并开始解析那些处于 <code>deferred</code> 模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为 “完成”，一个 “加载” 事件将随之触发。</p>
<h3><span id="构建呈现树render-tree">构建呈现树（Render Tree）</span></h3>
<p>在 <code>DOM</code> 树构建的同时，浏览器还会构建另一个树结构：<strong>呈现树</strong>。
这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。
作用：让按照正确的顺序绘制内容。</p>
<h4><span id="呈现树和-dom-树的关系">呈现树和 DOM 树的关系</span></h4>
<p>呈现器是和 <code>DOM</code> 元素相对应的，但并非一一对应。
非可视化的 <code>DOM</code> 元素不会插入呈现树中，例如 <code>&lt;head&gt;</code> 元素。如果元素的 <code>display</code> 属性值为 <code>none</code>，那么也不会显示在呈现树中（但是 <code>visibility</code> 属性值为 <code>hidden</code> 的元素仍会显示）。
有一些 DOM 元素对应多个可视化对象。例如 <code>&lt;select&gt;</code></p>
<p><img src="img/render_tree.png" alt="呈现树及其对应的 DOM 树" title="呈现树及其对应的 DOM 树">
呈现树和 DOM 树的关系</p>
<p>初始容器 <code>block</code> 为 <code>viewport</code>，而在 WebKit 中则为 <code>RenderView</code> 对象</p>
<h4><span id="渐进式处理">渐进式处理</span></h4>
<p>WebKit 使用一个标记来表示是否所有的顶级样式表（包括 <code>@imports</code>）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p>
<h3><span id="布局layout">布局（Layout）</span></h3>
<p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p>
<p>布局是一个基于流的递归的过程。它从根呈现器（对应于 HTML 文档的 <code>&lt;html&gt;</code> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</p>
<ul>
<li>
<p>全局布局：</p>
<ul>
<li>影响所有呈现器的全局样式更改（例如全局字体大小）。</li>
<li>屏幕大小调整。</li>
</ul>
</li>
<li>
<p>增量布局：异步执行，只对 <code>dirty</code> 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。当呈现器为 <code>dirty</code> 时，会异步触发增量布局</p>
</li>
</ul>
<h3><span id="绘制paint">绘制（Paint）</span></h3>
<p>在绘制阶段，系统会遍历呈现树，并调用呈现器的 <code>paint</code> 方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p>
<ul>
<li>全局绘制：绘制整个呈现树</li>
<li>增量绘制：部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件</li>
</ul>
<p>呈现树的绘制顺序：</p>
<ol>
<li>背景颜色</li>
<li>背景图片</li>
<li>边框</li>
<li>子代</li>
<li>轮廓</li>
</ol>
<blockquote>
<p>参考：<a href="//www.w3.org/TR/CSS21/zindex.html">CSS2 绘制顺序规范</a></p>
</blockquote>
<h3><span id="动态变化">动态变化</span></h3>
<p>在发生变化时，浏览器会尽可能做出最小的响应。</p>
<ul>
<li>颜色改变后，只会对该元素进行重绘。</li>
<li>位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。</li>
<li>添加 DOM 节点后，会对该节点进行布局和重绘。</li>
<li>一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</li>
</ul>
<h3><span id="呈现引擎和事件循环event-loop">呈现引擎和事件循环（Event Loop）</span></h3>
<p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。
网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p>
<p>浏览器的主线程是 <strong>事件循环</strong>。
它是一个 <strong>无限循环</strong>，永远处于接受处理状态，并等待事件（如布局、绘制、用户点击、系统事件等）发生，并进行处理。</p>
<h2><span id="参考资料">[参考资料]</span></h2>
<ul>
<li><a href="//fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>
<li><a href="//yuque.com/iwantoffer/notebook/wsd0ud">Network-当我们在浏览器中输入一个URL后，发生了什么？</a></li>
<li><a href="//igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">What really happens when you navigate to a URL</a></li>
<li><a href="//www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How Browsers Work</a></li>
<li><a href="//aosabook.org/en/posa/high-performance-networking-in-chrome.html">High Performance Networking in Chrome</a></li>
<li><a href="//www.alloyteam.com/2015/05/wang-ye-xing-neng-zhi-html-css-javascript/">网页性能之HTML,CSS,JavaScript</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript6 语法关键点]]></title>
      <url>https://blog.tiy.xyz/posts/2018/3526440553/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>通过阅读阮一峰老师著作《ECMAScript 6 入门》，提取和总结的 ECMAScript6 语法关键点</p>
<a id="more"></a>
<h2><span id="目录">目录</span></h2>
<ul>
<li><a href="#%E2%9C%8E-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">✎ 变量声明</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">✎ 变量的解构赋值</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7">技巧</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95">✎ 字符串的扩展</a></li>
<li><a href="#%E2%9C%8E-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95">✎ 正则表达式的扩展</a>
<ul>
<li><a href="#regexp-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">RegExp 构造函数</a></li>
<li><a href="#u-%E4%BF%AE%E9%A5%B0%E7%AC%A6">u 修饰符</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95">✎ 数值的扩展</a>
<ul>
<li><a href="#numberisfinite-%E5%92%8C-numberisnan">Number.isFinite 和 Number.isNaN</a></li>
<li><a href="#numberparseint-%E5%92%8C-numberparsefloat">Number.parseInt 和 Number.parseFloat</a></li>
<li><a href="#numberisinteger">Number.isInteger</a></li>
<li><a href="#numberepsilon">Number.EPSILON</a></li>
<li><a href="#mathsign">Math.sign</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95">✎ 函数的扩展</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">函数参数的默认值</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84-length-%E5%B1%9E%E6%80%A7">函数的 <code>length</code> 属性</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">函数定义</a></li>
<li><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96">尾调用优化</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95">✎ 数组的扩展</a>
<ul>
<li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8">扩展运算符的应用</a></li>
<li><a href="#arrayfrom">Array.from</a></li>
<li><a href="#arrayof">Array.of</a></li>
<li><a href="#copywithin">copyWithin()</a></li>
<li><a href="#find-%E5%92%8C-findindex">find() 和 findIndex()</a></li>
<li><a href="#fill">fill()</a></li>
<li><a href="#entries%E3%80%81keys-%E5%92%8C-values">entries()、keys() 和 values()</a></li>
<li><a href="#includes">includes()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D">数组的空位</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95">✎ 对象的扩展</a>
<ul>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F">属性名表达式</a></li>
<li><a href="#objectis">Object.is()</a></li>
<li><a href="#objectassign">Object.assign()</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86">属性的遍历</a></li>
<li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">对象的扩展运算符</a>
<ul>
<li><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">扩展运算符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E2%9C%8E-symbol">✎ Symbol</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84-symbol">作为属性名的 <code>Symbol</code></a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86">属性名的遍历</a></li>
<li><a href="#symbolfor">Symbol.for()</a></li>
<li><a href="#symbolkeyfor">Symbol.keyFor()</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">✎ Set 和 Map 数据结构</a>
<ul>
<li><a href="#set">Set</a></li>
<li><a href="#weakset">WeakSet</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#weakmap">WeakMap</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-proxy">✎ Proxy</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#proxy-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">Proxy 实例的方法</a>
<ul>
<li><a href="#get">get()</a></li>
<li><a href="#this-%E9%97%AE%E9%A2%98"><code>this</code> 问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E2%9C%8E-reflect">✎ Reflect</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-promise-%E5%AF%B9%E8%B1%A1">✎ Promise 对象</a>
<ul>
<li><a href="#promise-%E7%9A%84%E5%90%AB%E4%B9%89">Promise 的含义</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a href="#promiseprototypethen">Promise.prototype.then()</a></li>
<li><a href="#promiserace">Promise.race()</a></li>
<li><a href="#promiseresolve">Promise.resolve()</a></li>
<li><a href="#promisereject">Promise.reject()</a></li>
<li><a href="#%E9%99%84%E5%8A%A0%E6%96%B9%E6%B3%95">附加方法</a>
<ul>
<li><a href="#done"><code>done()</code></a></li>
<li><a href="#finally"><code>finally()</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E2%9C%8E-iterator-%E5%92%8C-forof-%E5%BE%AA%E7%8E%AF">✎ Iterator 和 for...of 循环</a>
<ul>
<li><a href="#iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5">Iterator（遍历器）的概念</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4-iterator-%E6%8E%A5%E5%8F%A3">默认 Iterator 接口</a></li>
<li><a href="#%E8%B0%83%E7%94%A8-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88">调用 <code>Iterator</code> 接口的场合</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-return%EF%BC%8Cthrow">遍历器对象的 <code>return()</code>，<code>throw()</code></a></li>
<li><a href="#forof-%E5%BE%AA%E7%8E%AF"><code>for...of</code> 循环</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E2%9C%8E-generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95">✎ Generator 函数的语法</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F">yield 表达式</a></li>
<li><a href="#%E4%B8%8E-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB">与 Iterator 接口的关系</a></li>
<li><a href="#next-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0">next() 方法的参数</a></li>
<li><a href="#forof-%E5%BE%AA%E7%8E%AF">for...of 循环</a></li>
<li><a href="#generatorprototypethrow">Generator.prototype.throw()</a></li>
<li><a href="#generatorprototypereturn">Generator.prototype.return()</a></li>
<li><a href="#next%E3%80%81throw%E3%80%81return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">next()、throw()、return() 的共同点</a></li>
<li><a href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F">yield* 表达式</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">✎ Generator 函数的异步调用</a>
<ul>
<li><a href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95">传统方法</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#%E5%8D%8F%E7%A8%8B">协程</a></li>
<li><a href="#thunk-%E5%87%BD%E6%95%B0">Thunk 函数</a></li>
<li><a href="#co-%E6%A8%A1%E5%9D%97">co 模块</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-async-%E5%87%BD%E6%95%B0">✎ async 函数</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">使用注意点</a></li>
<li><a href="#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">async 函数的实现原理</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">✎ Class 的基本语法</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></li>
<li><a href="#constructor-%E6%96%B9%E6%B3%95">constructor 方法</a></li>
<li><a href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">不存在变量提升</a></li>
<li><a href="#class-%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Class 的静态方法</a></li>
<li><a href="#class-%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">Class 的静态属性和实例属性</a></li>
<li><a href="#newtarget-%E5%B1%9E%E6%80%A7">new.target 属性</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-class-%E7%9A%84%E7%BB%A7%E6%89%BF">✎ Class 的继承</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C-proto-%E5%B1%9E%E6%80%A7">类的 <code>prototype</code> 属性和 <code>__proto__</code> 属性</a></li>
<li><a href="#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">原生构造函数的继承</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-decorator">✎ Decorator</a></li>
<li><a href="#%E2%9C%8E-module-%E7%9A%84%E8%AF%AD%E6%B3%95">✎ Module 的语法</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li>
<li><a href="#export-%E5%91%BD%E4%BB%A4">export 命令</a></li>
<li><a href="#import-%E5%91%BD%E4%BB%A4">import 命令</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD">模块的整体加载</a></li>
<li><a href="#export-default-%E5%91%BD%E4%BB%A4">export default 命令</a></li>
</ul>
</li>
<li><a href="#%E2%9C%8E-module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0">✎ Module 的加载实现</a>
<ul>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD">浏览器加载</a></li>
<li><a href="#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82">ES6 模块与 CommonJS 模块的差异</a>
<ul>
<li><a href="#%E5%AF%B9%E6%AF%94">对比</a></li>
<li><a href="#commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86">CommonJS 模块的加载原理</a></li>
</ul>
</li>
<li><a href="#node-%E5%8A%A0%E8%BD%BD">Node 加载</a>
<ul>
<li><a href="#%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F">内部变量</a></li>
<li><a href="#es6-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD-commonjs-%E6%A8%A1%E5%9D%97">ES6 模块加载 CommonJS 模块</a></li>
<li><a href="#commonjs-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD-es6-%E6%A8%A1%E5%9D%97">CommonJS 模块加载 ES6 模块</a></li>
</ul>
</li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">循环加载</a>
<ul>
<li><a href="#commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">CommonJS 模块的循环加载</a></li>
<li><a href="#es6-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">ES6 模块的循环加载</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E2%9C%8E-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC">✎ 编程风格</a></li>
<li><a href="#%E2%9C%8E-%E8%AF%BB%E6%87%82%E8%A7%84%E6%A0%BC">✎ 读懂规格</a></li>
<li><a href="#%E2%9C%8E-arraybuffer">✎ ArrayBuffer</a></li>
<li><a href="#%E2%9C%8E-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">✎ 参考链接</a></li>
</ul>
<h2><span id="变量声明">✎ 变量声明</span></h2>
<h3><span id="概述">概述</span></h3>
<ul>
<li>
<p>代码块，双大括号，拥有块级作用域</p>
</li>
<li>
<p>可不将大括号写在行首，取消 JavaScript 将其解释为代码块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考：变量的解构赋值（对象）</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>let</code> 声明的变量只在它所在的代码块有效</p>
</li>
<li>
<p><code>for</code> 循环中用 <code>let</code> 声明的 <code>i</code> 只在循环体内有效，且为父作用域内，与函数体作用域独立</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>let</code> 不存在变量申明提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>TDZ（Temporal Dead Zone），暂时性死区</p>
<blockquote>
<p>只要块级作用域内存在 <code>let</code> 命令，它所声明的变量就 “绑定”（binding）这个区域，不再受外部的影响。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError: tmp is not defined</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“暂时性死区” 也意味着 <code>typeof</code> 不再是一个百分之百安全的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不允许重复声明</p>
</li>
<li>
<p><code>const</code> 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</p>
</li>
<li>
<p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>let</code>、<code>const</code> 和 <code>class</code> 命令声明的全局变量，不属于顶层对象（如 <code>window</code>）的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="变量的解构赋值">✎ 变量的解构赋值</span></h2>
<h3><span id="概述">概述</span></h3>
<ul>
<li>
<p>默认值：解构赋值指定默认值时，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于 <code>undefined</code>，默认值是不会生效的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数的参数也可以使用解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="技巧">技巧</span></h3>
<ul>
<li>
<p>交换变量的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>遍历 <code>Map</code> 结构</p>
<blockquote>
<p>任何部署了 <code>Iterator</code> 接口的对象，都可以用 <code>for...of</code> 循环遍历。<code>Map</code> 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只想获取键名，或者只想获取键值，可以写成下面这样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="字符串的扩展">✎ 字符串的扩展</span></h2>
<ul>
<li>
<p><code>codePointAt</code> 方法会正确返回<code>32位</code>的 <code>UTF-16</code> 字符的码点（10进制）。对于那些两个字节储存的常规字符，它的返回结果与 <code>charCodeAt</code> 方法相同</p>
</li>
<li>
<p>使用 <code>for...of</code> 循环，因为它会正确识别<code>32位</code>的<code>UTF-16</code>字符（可以识别大于 <code>0xFFFF</code> 的码点）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>codePointAt</code> 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>); <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="正则表达式的扩展">✎ 正则表达式的扩展</span></h2>
<h3><span id="regexp-构造函数">RegExp 构造函数</span></h3>
<blockquote>
<p>如果 <code>RegExp</code> 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。
而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</span><br><span class="line"><span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
<h3><span id="u-修饰符">u 修饰符</span></h3>
<ul>
<li>
<p>ES6 对正则表达式添加了 <code>u</code> 修饰符，含义为 “<code>Unicode</code> 模式”，用来正确处理大于 <code>\uFFFF</code> 的 <code>Unicode</code> 字符。也就是说，会正确处理 4个字节 的 <code>UTF-16</code> 编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>); <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一旦加上u修饰符号，就会修改下面这些正则表达式的行为</p>
<ul>
<li>
<p>点字符</p>
<blockquote>
<p>对于码点大于<code>0xFFFF</code>的 <code>Unicode</code> 字符，点字符不能识别，必须加上 <code>u</code> 修饰符</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line">/^.$/.test(s); <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Unicode</code> 字符表示法</p>
<blockquote>
<p>ES6 新增了使用大括号表示 <code>Unicode</code> 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>); <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>); <span class="comment">// true</span></span><br><span class="line">/\u&#123;<span class="number">20</span>BB7&#125;/u.test(<span class="string">'𠮷'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2><span id="数值的扩展">✎ 数值的扩展</span></h2>
<h3><span id="numberisfinite-和-numberisnan">Number.isFinite 和 Number.isNaN</span></h3>
<blockquote>
<p>它们与传统的全局方法 <code>isFinite()</code> 和 <code>isNaN()</code> 的区别在于，传统方法先调用 <code>Number()</code> 将非数值的值转为数值，再进行判断，
而这两个新方法只对数值有效，<code>Number.isFinite()</code> 对于非数值一律返回 <code>false</code>，而 <code>Number.isNaN()</code> 只有对于 <code>NaN</code> 才返回 <code>true</code>，<code>非NaN</code> 一律返回 <code>false</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; global_isFinite(value);</span><br></pre></td></tr></table></figure>
<h3><span id="numberparseint-和-numberparsefloat">Number.parseInt 和 Number.parseFloat</span></h3>
<p>从 <code>window</code> 对象上移植到 <code>Number</code> 对象上，行为不变</p>
<h3><span id="numberisinteger">Number.isInteger</span></h3>
<p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">"15"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3><span id="numberepsilon">Number.EPSILON</span></h3>
<ul>
<li>ES6 在<code>Number</code>对象上面，新增一个极小的常量 <code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</li>
<li><code>Number.EPSILON</code> 实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了</li>
</ul>
<h3><span id="mathsign">Math.sign</span></h3>
<p><code>Math.sign</code> 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值：</p>
<ul>
<li>参数为正数，返回 <code>+1</code>；</li>
<li>参数为负数，返回 <code>-1</code>；</li>
<li>参数为 0，返 回<code>0</code>；</li>
<li>参数为-0，返回 <code>-0</code>;</li>
<li>其他值，返回 <code>NaN</code>。</li>
</ul>
<h2><span id="函数的扩展">✎ 函数的扩展</span></h2>
<h3><span id="函数参数的默认值">函数参数的默认值</span></h3>
<blockquote>
<p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo(); <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<h3><span id="函数的-length-属性">函数的 <code>length</code> 属性</span></h3>
<blockquote>
<p><code>length</code> 属性的含义是，该函数<strong>预期传入</strong>的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了
指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code> 属性将失真。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length; <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length; <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length; <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length; <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length; <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3><span id="函数定义">函数定义</span></h3>
<blockquote>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure>
<h3><span id="尾调用优化">尾调用优化</span></h3>
<blockquote>
<p>定义：某个函数的最后一步是调用另一个函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的最后一步是调用函数 g，这就叫尾调用</p>
<p>以下三种情况，都<strong>不属于</strong>尾调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了
“尾调用优化” 对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。
ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署 “尾调用优化”。
这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存</p>
</blockquote>
<h2><span id="数组的扩展">✎ 数组的扩展</span></h2>
<h3><span id="扩展运算符的应用">扩展运算符的应用</span></h3>
<blockquote>
<p>扩展运算符有一个重要的好处，那就是能够正确识别 <strong>4</strong>个字节 的 <code>Unicode 字符</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length; <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一种写法，JavaScript会将 4个字节 的 <code>Unicode</code> 字符，识别为 <strong>2</strong> 个字符，采用扩展运算符就没有这个问题。
因此，正确返回字符串长度的函数，可以像下面这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>凡是涉及到操作4个字节的 <code>Unicode</code> 字符的函数，都有这个问题。因此，最好都用扩展运算符改写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果不用扩展运算符，字符串的 <code>reverse</code> 操作就不正确</p>
<h3><span id="arrayfrom">Array.from</span></h3>
<blockquote>
<p><code>Array.from()</code> 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 <code>Unicode</code> 字符，可以避免JavaScript将<strong>大于</strong> <code>\uFFFF</code> 的<code>Unicode</code>字符，算作两个字符的bug。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="arrayof">Array.of</span></h3>
<blockquote>
<p><code>Array.of</code> 方法用于将一组值，转换为数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3><span id="copywithin">copyWithin()</span></h3>
<blockquote>
<p>组实例的 <code>copyWithin</code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。
也就是说，使用这个方法，会修改当前数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3><span id="find-和-findindex">find() 和 findIndex()</span></h3>
<ul>
<li>
<p>数组实例的 <code>find</code> 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 <code>true</code> 的成员，然后返回该成员。如果没有符合条件的成员，则返回 <code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>find</code> 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
</li>
<li>
<p>数组实例的 <code>findIndex</code> 方法的用法与 <code>find</code> 方法非常类似，返回第一个符合条件的数组成员的<strong>位置</strong>，如果所有成员都不符合条件，则返回 <code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="fill">fill()</span></h3>
<blockquote>
<p><code>fill</code> 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure>
<h3><span id="entries-keys-和-values">entries()、keys() 和 values()</span></h3>
<blockquote>
<p>用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 <code>for...of</code> 循环进行遍历，唯一的区别是：</p>
</blockquote>
<ul>
<li><code>keys()</code> 是对键名的遍历</li>
<li><code>values()</code>是对键值的遍历</li>
<li><code>entries()</code>是对键值对的遍历</li>
</ul>
<h3><span id="includes">includes()</span></h3>
<blockquote>
<p><code>Array.prototype.includes</code> 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 <code>includes</code> 方法类似。ES2016 引入了该方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3><span id="数组的空位">数组的空位</span></h3>
<ul>
<li>
<p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code> 构造函数返回的数组都是空位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是 <code>undefined</code>，一个位置的值等于 <code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code> 运算符可以说明这一点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>ES5</strong> 对空位的处理，已经很不一致了，大多数情况下会忽略空位：</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和 <code>some()</code> 都会跳过空位</li>
<li><code>map()</code> 会跳过空位，但会保留这个值</li>
<li><code>join()</code> 和 <code>toString()</code> 会将空位视为 <code>undefined</code>，而 <code>undefined</code> 和 <code>null</code> 会被处理成空字符串</li>
</ul>
</li>
<li>
<p><strong>ES6</strong> 则是明确将空位转为 <code>undefined</code> ：</p>
<ul>
<li>
<p><code>Array.from</code>、扩展运算符（<code>...</code>） 方法会将数组的空位，转为 <code>undefined</code>，也就是说，这个方法不会忽略空位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>]);</span><br><span class="line"><span class="comment">// [ "a", undefined, "b" ]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>fill()</code> 会将空位视为正常的数组位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>copyWithin()</code> 会连空位一起拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>for...of</code> 循环也会遍历空位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code> 和 <code>findIndex()</code> 会将空位处理成 <code>undefined</code></p>
</li>
</ul>
</li>
<li>
<p><strong>由于空位的处理规则非常不统一，所以建议避免出现空位</strong></p>
</li>
</ul>
<h2><span id="对象的扩展">✎ 对象的扩展</span></h2>
<h3><span id="属性名表达式">属性名表达式</span></h3>
<p>可用 <strong>表达式</strong> 作为对象的属性名，即把表达式放在方括号内：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表达式还可以用于定义方法名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
<h3><span id="objectis">Object.is()</span></h3>
<blockquote>
<p>“Same-value equality”，同值相等，<code>Object.is</code> 就是部署这个算法的新方法。
它用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。不同之处只有两个：</p>
</blockquote>
<ul>
<li><code>+0</code> 不等于 <code>-0</code></li>
<li><code>NaN</code> 等于自身</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3><span id="objectassign">Object.assign()</span></h3>
<ul>
<li>
<p><code>Object.assign</code> 方法用于对象的合并，将源对象（<code>source</code>）的所有可枚举属性，复制到目标对象（<code>target</code>）如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果只有一个参数，<code>Object.assign</code> 会直接返回该参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>); <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数值、字符串和布尔值不在首参数，不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。因为只有字符串的包装对象，会产生可枚举属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li>
<p><code>Object.assign</code> 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同名属性的替换</p>
<p>对于嵌套的对象，一旦遇到同名属性，<code>Object.assign</code> 的处理方法是替换，而不是添加</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组的处理</p>
<p><code>Object.assign</code> 可以用来处理数组，但是会把数组视为对象</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">Object</span>.assign(arr1, [<span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">arr1 <span class="comment">// [4, 5, 3, 4]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>取值函数的处理</p>
<p><code>Object.assign</code> 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  get foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>source</code> 对象的 <code>foo</code> 属性是一个取值函数，<code>Object.assign</code> 不会复制这个取值函数，只会拿到值以后，将这个值复制过去</p>
</li>
</ol>
<h3><span id="属性的遍历">属性的遍历</span></h3>
<p>属性遍历的次序规则：</p>
<ol>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 <code>Symbol</code> 键，按照加入时间升序排列</li>
</ol>
<h3><span id="super-关键字">super 关键字</span></h3>
<p>指向当前对象的<strong>原型对象</strong></p>
<blockquote>
<p><code>super</code> 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。
目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="对象的扩展运算符">对象的扩展运算符</span></h3>
<h4><span id="解构赋值">解构赋值</span></h4>
<blockquote>
<p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。
所有的键和它们的值，都会拷贝到新对象上面。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">o3.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4><span id="扩展运算符">扩展运算符</span></h4>
<blockquote>
<p>扩展运算符（<code>...</code>）用于取出参数对象的所有<strong>可遍历</strong>属性，拷贝到当前对象之中。</p>
</blockquote>
<p>扩展运算符可以用于合并两个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>扩展运算符的参数对象之中，如果有取值函数 <code>get</code>，这个函数是会执行的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  get x() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not throw yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为 x 属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    get x() &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="symbol">✎ Symbol</span></h2>
<h3><span id="概述">概述</span></h3>
<ul>
<li>
<p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li>布尔值（<code>Boolean</code>）</li>
<li>字符串（<code>String</code>）</li>
<li>数值（<code>Number</code>）</li>
<li>对象（<code>Object</code>）</li>
</ul>
</li>
<li>
<p><code>Symbol</code> 函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的 <code>Symbol</code> 函数的返回值是不相等的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Symbol</code> 值不能与其他类型的值进行运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"your symbol is "</span> + sym;</span><br><span class="line"><span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Symbol</code> 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString(); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym2); <span class="comment">// true</span></span><br><span class="line">!sym2  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym2) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym2); <span class="comment">// TypeError</span></span><br><span class="line">sym2 + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="作为属性名的-symbol">作为属性名的 <code>Symbol</code></span></h3>
<blockquote>
<p><code>Symbol</code> 值作为对象属性名时，不能用点运算符，该属性还是公开属性，不是私有属性</p>
</blockquote>
<h3><span id="属性名的遍历">属性名的遍历</span></h3>
<blockquote>
<p><code>Symbol</code> 作为属性名，该属性不会出现在 <code>for...in</code>、<code>for...of</code> 循环中，
也不会被 <code>Object.keys()</code> 、<code>Object.getOwnPropertyNames()</code> 、 <code>JSON.stringify()</code> 返回。
但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名</p>
</blockquote>
<p><code>Reflect.ownKeys()</code> 方法可以返回所有类型的键名，包括常规键名和 <code>Symbol</code> 键名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>
<h3><span id="symbolfor">Symbol.for()</span></h3>
<blockquote>
<p><code>Symbol.for</code> 方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。
如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Symbol.for()</code> 与 <code>Symbol()</code> 这两种写法，都会生成新的 <code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
<code>Symbol.for()</code> 不会每次调用就返回一个新的 <code>Symbol</code> 类型的值，而是会先检查给定的 <code>key</code> 是否已经存在，如果不存在才会新建一个值。
比如，如果你调用 <code>Symbol.for(&quot;cat&quot;)</code> 30 次，每次都会返回同一个 <code>Symbol</code> 值，
但是调用 <code>Symbol(&quot;cat&quot;)</code> 30 次，会返回 30 个不同的 <code>Symbol</code> 值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3><span id="symbolkeyfor">Symbol.keyFor()</span></h3>
<blockquote>
<p><code>Symbol.keyFor</code> 方法返回一个已登记的 <code>Symbol</code> 类型值的 <code>key</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 <code>s2</code> 属于未登记的 <code>Symbol</code> 值，所以返回 <code>undefined</code></p>
<p>需要注意的是，<code>Symbol.for</code> 为 <code>Symbol</code> 值登记的名字，是全局环境的，可以在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>iframe</code> 窗口生成的 <code>Symbol</code> 值，可以在主页面得到</p>
<h2><span id="set-和-map-数据结构">✎ Set 和 Map 数据结构</span></h2>
<h3><span id="set">Set</span></h3>
<blockquote>
<p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值</p>
</blockquote>
<h3><span id="weakset">WeakSet</span></h3>
<ul>
<li>
<p><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与 <code>Set</code> 有两个区别：</p>
<ul>
<li>
<p>首先，<code>WeakSet</code> 的成员只能是<strong>对象</strong>，而不能是其他类型的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>上面代码试图向 <code>WeakSet</code> 添加一个数值和 <code>Symbol</code> 值，结果报错，因为 <code>WeakSet</code> 只能放置对象。</p>
</li>
<li>
<p>其次，<code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用。
也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中</p>
<blockquote>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。
结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。
WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
因此，<code>WeakSet</code> 适合临时存放一组对象，以及存放跟对象绑定的信息。
只要这些对象在外部消失，它在 <code>WeakSet</code> 里面的引用就会自动消失
由于上面这个特点，<code>WeakSet</code> 的成员是不适合引用的，因为它会随时消失。
另外，由于 <code>WeakSet</code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，
而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet</code> 不可遍历</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>WeakSet</code> 可以接受一个数组或类似数组的对象作为参数（实际上，任何具有 <code>Iterable</code> 接口的对象，都可以作为 <code>WeakSet</code> 的参数）。该数组的所有成员（必须都为<strong>对象</strong>），都会自动成为 <code>WeakSet</code> 实例对象的成员</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>WeakSet</code> 的一个用处，是储存 <code>DOM</code> 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</p>
</li>
</ul>
<h3><span id="map">Map</span></h3>
<blockquote>
<p><code>ES6</code> 提供了 <code>Map</code> 数据结构。它类似于对象，也是键值对的集合，但是 “键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
也就是说，<code>Object</code> 结构提供了 “字符串 — 值” 的对应，<code>Map</code> 结构提供了 “值 — 值” 的对应，是一种更完善的 <code>Hash</code> 结构实现。
如果你需要 “键值对” 的数据结构，<code>Map</code> 比 <code>Object</code> 更合适</p>
</blockquote>
<p>作为构造函数，<code>Map</code> 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>); <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>); <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure>
<h3><span id="weakmap">WeakMap</span></h3>
<blockquote>
<p><code>WeakMap</code> 的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code> 结构有助于防止内存泄漏</p>
</blockquote>
<p><code>WeakMap</code> 与 <code>Map</code> 的区别：</p>
<ol>
<li>
<p><code>WeakMap</code> 只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>WeakMap</code> 的键名所指向的对象，不计入垃圾回收机制</p>
<blockquote>
<p><code>WeakMap</code> 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。
<code>WeakMap</code> 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。
因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。
也就是说，一旦不再需要，<code>WeakMap</code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(el, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(el) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>WeakMap</code> 与 <code>Map</code> 在 API 上的区别主要是两个：</p>
<ul>
<li>没有遍历操作（即没有 <code>key()</code>、 <code>values()</code> 和 <code>entries()</code> 方法），也没有 <code>size</code> 属性</li>
<li>无法清空，即不支持clear方法</li>
</ul>
</li>
</ol>
<h2><span id="proxy">✎ Proxy</span></h2>
<h3><span id="概述">概述</span></h3>
<ul>
<li>
<p><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种 “元编程”（meta programming），即对编程语言进行编程。
<code>Proxy</code> 可以理解成，在目标对象之前架设一层 “拦截”，外界对该对象的访问，都必须先通过这层拦截，
因此提供了一种机制，可以对外界的访问进行过滤和改写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果 <code>handler</code> 没有设置任何拦截，那就等同于直接通向原对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="proxy-实例的方法">Proxy 实例的方法</span></h3>
<h4><span id="get">get()</span></h4>
<blockquote>
<p>如果一个属性不可配置（<code>configurable</code>）和不可写（<code>writable</code>），则该属性不能被代理，通过 <code>Proxy</code> 对象访问该属性会报错</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo <span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure>
<h4><span id="this-问题"><code>this</code> 问题</span></h4>
<blockquote>
<p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。
主要原因就是在 <code>Proxy</code> 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 <code>Proxy</code> 代理</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m(); <span class="comment">// false</span></span><br><span class="line">proxy.m();  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2><span id="reflect">✎ Reflect</span></h2>
<h3><span id="概述">概述</span></h3>
<ul>
<li>
<p><code>Reflect</code> 对象与 <code>Proxy</code> 对象一样，也是 <code>ES6</code> 为了操作对象而提供的新 API</p>
</li>
<li>
<p><code>Reflect</code> 对象的设计目的有这样几个：</p>
<ul>
<li>
<p>将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code>），放到 <code>Reflect</code> 对象上。
现阶段，某些方法同时在 <code>Object</code> 和 <code>Reflect</code> 对象上部署，未来的新方法将只部署在 <code>Reflect</code> 对象上。
也就是说，从 <code>Reflect</code> 对象上可以拿到语言内部的方法</p>
</li>
<li>
<p>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。
比如，<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一个错误，
而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>让 <code>Object</code> 操作都变成函数行为。某些 <code>Object</code> 操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code> ，
而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> success = <span class="built_in">Reflect</span>.set(target,name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2><span id="promise-对象">✎ Promise 对象</span></h2>
<h3><span id="promise-的含义">Promise 的含义</span></h3>
<ul>
<li>
<p>所谓 <code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 <code>API</code>，各种异步操作都可以用同样的方法进行处理</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p>对象的状态不受外界影响</p>
<blockquote>
<p><code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。
只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p>
</blockquote>
</li>
<li>
<p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p>
<blockquote>
<p><code>Promise</code> 对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code>。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>无法取消 <code>Promise</code>，一旦新建它就会立即执行，无法中途取消</li>
<li>如果不设置回调函数，<code>Promise</code> 内部抛出的错误，不会反应到外部</li>
<li>当处于 <code>pending</code> 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li>
</ul>
</li>
</ul>
<h3><span id="基本用法">基本用法</span></h3>
<ul>
<li>
<p>如果调用 <code>resolve</code> 函数和 <code>reject</code> 函数时带有参数，那么它们的参数会被传递给回调函数。
（如果参数是 <code>Promise</code> 的实例，那么参数的状态就会传递给改 <code>Promise</code> 的状态，即参数实例的状态决定了改实例的状态）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用 <code>resolve</code> 或 <code>reject</code> 并不会终结 <code>Promise</code> 的参数函数的执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>说明：立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</p>
</li>
</ul>
<h3><span id="promiseprototypethen">Promise.prototype.then()</span></h3>
<blockquote>
<p>采用链式的 <code>then</code>，可以指定一组按照次序调用的回调函数。
这时，前一个回调函数，有可能返回的还是一个 <code>Promise</code> 对象（即有异步操作），
这时后一个回调函数，就会等待该 <code>Promise</code> 对象的状态发生变化，才会被调用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>)</span><br><span class="line">  .then(</span><br><span class="line">    post =&gt; getJSON(post.commentURL)</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.warn(<span class="string">"rejected: "</span>, err)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h3><span id="promiserace">Promise.race()</span></h3>
<blockquote>
<p><code>Promise.race</code> 方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。
那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 p 的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果 5 秒之内 <code>fetch</code> 方法无法返回结果，变量 <code>p</code> 的状态就会变为 <code>rejected</code>，从而触发 <code>catch</code> 方法指定的回调函数</p>
<h3><span id="promiseresolve">Promise.resolve()</span></h3>
<blockquote>
<p>将现有对象转为 <code>Promise</code> 对象</p>
</blockquote>
<p><code>Promise.resolve</code> 方法的参数分成四种情况：</p>
<ol>
<li>
<p>参数是一个 <code>Promise</code> 实例</p>
<blockquote>
<p>如果参数是 <code>Promise</code> 实例，那么 <code>Promise.resolve</code> 将不做任何修改、原封不动地返回这个实例</p>
</blockquote>
</li>
<li>
<p>参数是一个 <code>thenable</code> 对象</p>
<blockquote>
<p><code>thenable</code> 对象指的是具有 <code>then</code> 方法的对象</p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">   then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     resolve(<span class="number">42</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve</code> 方法会将这个对象转为 <code>Promise</code> 对象，然后就立即执行 <code>thenable</code> 对象的 <code>then</code> 方法</p>
</li>
<li>
<p>参数不是具有 <code>then</code> 方法的对象，或根本就不是对象</p>
<blockquote>
<p>如果参数是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，则 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为 <code>resolved</code></p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不带有任何参数</p>
<blockquote>
<p><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个 <code>resolved</code> 状态的 <code>Promise</code> 对象</p>
</blockquote>
<p>注意：立即 <code>resolve</code> 的 <code>Promise</code> 对象，是在本轮 “事件循环”（<code>event loop</code>）的结束时，而不是在下一轮 “事件循环” 的开始时</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，
<code>setTimeout(fn, 0)</code> 在下一轮 “事件循环” 开始时执行，
<code>Promise.resolve()</code> 在本轮 “事件循环” 结束时执行，
<code>console.log('one')</code> 则是立即执行，因此最先输出</p>
</li>
</ol>
<h3><span id="promisereject">Promise.reject()</span></h3>
<blockquote>
<p><code>Promise.reject(reason)</code> 方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为 <code>rejected</code></p>
</blockquote>
<p>注意：<code>Promise.reject()</code> 方法的参数，会原封不动地作为 <code>reject</code> 的理由，变成后续方法的参数。这一点与 <code>Promise.resolve</code> 方法不一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Promise.reject</code> 方法的参数是一个 <code>thenable</code> 对象，执行以后，后面 <code>catch</code> 方法的参数不是 <code>reject</code> 抛出的 <em>“出错了”</em> 这个字符串，而是 <code>thenable</code> 对象。</p>
<h3><span id="附加方法">附加方法</span></h3>
<h4><span id="done"><code>done()</code></span></h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="built_in">Promise</span>.prototype.done || <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="finally"><code>finally()</code></span></h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="built_in">Promise</span>.prototype.finally || <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="iterator-和-forof-循环">✎ Iterator 和 for...of 循环</span></h2>
<h3><span id="iterator遍历器的概念">Iterator（遍历器）的概念</span></h3>
<blockquote>
<p>遍历器（<code>Iterator</code>）是一种接口，为各种不同的数据结构提供统一的访问机制。
任何数据结构只要部署 <code>Iterator</code> 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</p>
</blockquote>
<p><code>Iterator</code> 的作用：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口</li>
<li>使得数据结构的成员能够按某种次序排列</li>
<li>ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，<code>Iterator</code> 接口主要供 <code>for...of</code> 消费</li>
</ol>
<h3><span id="默认-iterator-接口">默认 Iterator 接口</span></h3>
<ul>
<li>
<p>当使用 <code>for...of</code> 循环遍历某种数据结构时，该循环会自动去寻找 <code>Iterator</code> 接口。一种数据结构只要部署了 <code>Iterator</code> 接口，我们就称这种数据结构是 “可遍历的”（<code>iterable</code>）</p>
</li>
<li>
<p><code>ES6</code> 规定，默认的 <code>Iterator</code> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要具有 <code>Symbol.iterator</code> 属性，就可以认为是“可遍历的”（<code>iterable</code>）。<code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 <code>Symbol.iterator</code>，它是一个表达式，返回 <code>Symbol</code> 对象的 <code>iterator</code> 属性，这是一个预定义好的、类型为 <code>Symbol</code> 的特殊值，所以要放在方括号内</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>凡是部署了 <code>Symbol.iterator</code> 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象</p>
</li>
<li>
<p>对于类似数组的对象（存在数值键名和 <code>length</code> 属性），部署 <code>Iterator</code> 接口，有一个简便方法，就是 <code>Symbol.iterator</code> 方法直接引用数组的 <code>Iterator</code> 接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="调用-iterator-接口的场合">调用 <code>Iterator</code> 接口的场合</span></h3>
<ul>
<li>
<p>解构赋值</p>
<p>对 <code>Array</code> 和 <code>Set</code> 结构进行解构赋值时，会默认调用 <code>Symbol.iterator</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">let</span> [x, y] = set; <span class="comment">// x='a'; y='b'</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>扩展运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str]; <span class="comment">// ['h','e','l','l','o']</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>yield*</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其他场合</p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口：</p>
<ul>
<li><code>for...of</code></li>
<li><code>Array.from()</code></li>
<li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code></li>
<li><code>Promise.all()</code></li>
<li><code>Promise.race()</code></li>
</ul>
</li>
</ul>
<h3><span id="遍历器对象的-returnthrow">遍历器对象的 <code>return()</code>，<code>throw()</code></span></h3>
<ul>
<li>
<p>遍历器对象除了具有 <code>next</code> 方法，还可以具有 <code>return</code> 方法和 <code>throw</code> 方法。如果你自己写遍历器对象生成函数，那么 <code>next</code> 方法是必须部署的，<code>return</code> 方法和 <code>throw</code> 方法是否部署是可选的</p>
</li>
<li>
<p><code>return</code> 方法的使用场合是：如果 <code>for...of</code> 循环提前退出（通常是因为出错，或者有 <code>break</code> 语句或 <code>continue</code> 语句），就会调用 <code>return</code> 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 <code>return</code> 方法。注意，<code>return</code> 方法<strong>必须返回一个对象</strong>，这是 <code>Generator</code> 规格决定的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">return</span>() &#123;</span><br><span class="line">      file.close();</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>throw</code> 方法主要是配合 <code>Generator</code> 函数使用，一般的遍历器对象用不到这个方法</p>
</li>
</ul>
<h3><span id="forof-循环"><code>for...of</code> 循环</span></h3>
<h4><span id="数组">数组</span></h4>
<ul>
<li>
<p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 <code>iterator</code> 接口，就可以用 <code>for...of</code> 循环遍历它的成员。也就是说，<code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法</p>
</li>
<li>
<p><code>for...of</code> 循环可以使用的范围包括 <code>Array</code>、<code>Set</code> 和 <code>Map</code> 结构、某些类似数组的对象（比如 <code>arguments</code> 对象、<code>DOM NodeList</code> 对象）、<code>Generator</code> 对象，以及 <code>字符串</code></p>
</li>
<li>
<p>与 <code>for...in</code> 的区别：</p>
<ul>
<li><code>for...in</code> 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 <code>for...of</code> 循环，允许遍历获得键值</li>
<li><code>for...of</code> 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  "3", "5", "7"， 不包含 'foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4><span id="字符串">字符串</span></h4>
<p>对于字符串来说，<code>for...of</code> 循环还有一个特点，就是会正确识别 32 位 <code>UTF-16</code> 字符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">'a\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// '\uD83D\uDC0A'</span></span><br></pre></td></tr></table></figure>
<h2><span id="generator-函数的语法">✎ Generator 函数的语法</span></h2>
<h3><span id="简介">简介</span></h3>
<ol>
<li><code>Generator</code> 函数是 <code>ES6</code> 提供的一种异步编程解决方案</li>
<li><code>Generator</code> 函数是一个<em>状态机</em>，封装了多个内部状态</li>
<li><code>Generator</code> 函数执行后返回一个<em>遍历器对象</em>，也就是说，<code>Generator</code> 函数除了状态机，还是一个遍历器对象生成函数</li>
</ol>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<blockquote>
<p>调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。
以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象：
<code>value</code> 属性表示当前的内部状态的值，是 <code>yield</code> 表达式后面那个表达式的值；
<code>done</code> 属性是一个布尔值，表示是否遍历结束</p>
</blockquote>
<h3><span id="yield-表达式">yield 表达式</span></h3>
<ul>
<li><code>yield</code> 表达式 表示遍历器对象的暂停标识</li>
<li><code>yield</code> 表达式 如果用在另一个表达式之中，必须放在 <em>圆括号</em> 里面</li>
<li><code>yield</code> 表达式 本身没有返回值，或者说总是返回 <code>undefined</code></li>
<li>紧跟在 <code>yield</code> 后面的那个表达式的值，作为 <code>next()</code> 返回的对象的 <code>value</code> 属性值</li>
<li><code>return</code> 后表示遍历结束状态时，返回值作为遍历后 <code>value</code> 的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="与-iterator-接口的关系">与 Iterator 接口的关系</span></h3>
<blockquote>
<p>任意一个对象的 <code>Symbol.iterator</code> 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象</p>
</blockquote>
<p>由于 <code>Generator</code> 函数就是遍历器生成函数，因此可以把 <code>Generator</code> 赋值给对象的 <code>Symbol.iterator</code> 属性，从而使得该对象具有 <code>Iterator</code> 接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3><span id="next-方法的参数">next() 方法的参数</span></h3>
<blockquote>
<p><code>next</code> 方法可以带一个参数，该参数就会被当作 <strong>上一个</strong> <code>yield</code> 表达式的返回值</p>
</blockquote>
<p>注意： 由于 <code>next</code> 方法的参数表示 <strong>上一个</strong> <code>yield</code> 表达式的返回值，所以在 <strong>第一次</strong> 使用 <code>next</code> 方法时，传递参数是无效的。
从语义上讲，第一个 <code>next</code> 方法用来启动遍历器对象，所以不用带有参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<h3><span id="forof-循环">for...of 循环</span></h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用 <code>for...of</code> 循环，依次显示 <strong>2</strong> 个 <code>yield</code> 表达式的值。
这里需要注意，一旦 <code>next</code> 方法的返回对象的 <code>done</code> 属性为 <code>true</code>，<code>for...of</code> 循环就会中止，且不包含该返回对象，
所以上面代码的 <code>return</code> 语句返回的 <code>3</code> 和之后的 <code>4</code>，不包括在 <code>for...of</code> 循环之中</p>
<blockquote>
<p>除了 <code>for...of</code> 循环以外，扩展运算符（<code>...</code>）、解构赋值和 <code>Array.from</code> 方法内部调用的，都是遍历器接口。
这意味着，它们都可以将 <code>Generator</code> 函数返回的 <code>Iterator</code> 对象，作为参数
<strong>自注</strong>： 一旦执行了 <code>next()</code> 之后，再进行遍历操作（解构赋值、扩展运算等），
结果中将<strong>不包含</strong> <code>next()</code> 之前的返回结果，即从 <code>Generator</code> 对象当前的状态开始遍历</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = Gen();</span><br><span class="line"></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">[...g] <span class="comment">// [2, 3, 4]</span></span><br><span class="line">[...g] <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>for...of</code> 的本质是一个 <code>while</code> 循环，所以上面的代码实质上执行的是下面的逻辑</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> it = iterateJobs(jobs);</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.done)&#123;</span><br><span class="line">  <span class="keyword">let</span> result = res.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="generatorprototypethrow">Generator.prototype.throw()</span></h3>
<ul>
<li>
<p><code>throw</code> 方法，可以在函数体<strong>外</strong>抛出错误，然后在 <code>Generator</code> 函数体<strong>内</strong>捕获</p>
</li>
<li>
<p><code>throw</code> 方法被捕获以后，会附带执行下一条 <code>yield</code> 表达式。也就是说，会附带执行一次 <code>next()</code> 方法</p>
</li>
<li>
<p>只要 <code>Generator</code> 函数内部部署了 <code>try...catch</code> 代码块，那么遍历器的 <code>throw</code> 方法抛出的错误，不影响下一次遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next(); <span class="comment">// a</span></span><br><span class="line">g.throw(); <span class="comment">// b</span></span><br><span class="line">g.next(); <span class="comment">// c</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一旦 <code>Generator</code> 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 <code>next()</code> 方法，将返回一个 <code>value</code> 属性等于 <code>undefined</code> 、<code>done</code> 属性等于 <code>true</code> 的对象，即 JavaScript 引擎认为这个 <code>Generator</code> 已经运行结束了</p>
</li>
</ul>
<h3><span id="generatorprototypereturn">Generator.prototype.return()</span></h3>
<blockquote>
<p><code>return</code> 方法，可以返回给定的值，并且终结遍历 <code>Generator</code> 函数</p>
</blockquote>
<p>如果 <code>Generator</code> 函数内部有 <code>try...finally</code> 代码块，那么 <code>return</code> 方法会推迟到 <code>finally</code> 代码块执行完再执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = numbers();</span><br><span class="line">g.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用 <code>return</code> 方法后，就开始执行 <code>finally</code> 代码块，然后等到 <code>finally</code> 代码块执行完，再执行 <code>return</code> 方法</p>
<h3><span id="next-throw-return-的共同点">next()、throw()、return() 的共同点</span></h3>
<blockquote>
<p><code>next()</code>、<code>throw()</code>、<code>return()</code> 这三个方法本质上是同一件事，可以放在一起理解。
它们的作用都是让 <code>Generator</code> 函数<em>恢复执行</em>，并且使用不同的语句替换 <code>yield</code> 表达式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br><span class="line"></span><br><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error('出错了'))</span></span><br><span class="line"><span class="comment">// ;</span></span><br><span class="line"></span><br><span class="line">gen.return(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure>
<h3><span id="yield-表达式">yield* 表达式</span></h3>
<blockquote>
<p><code>yield*</code> 表达式，用来在一个 <code>Generator</code> 函数里面执行另一个 <code>Generator</code> 函数</p>
</blockquote>
<ul>
<li>
<p>如果在 <code>Generator</code> 函数内部，调用另一个 <code>Generator</code> 函数，默认情况下是没有效果的</p>
</li>
<li>
<p>从语法角度看，如果 <code>yield</code> 表达式后面跟的是一个遍历器对象，需要在 <code>yield</code> 表达式后面加上<strong>星号</strong>，表明它返回的是一个遍历器对象。这被称为 <code>yield*</code> 表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>yield*</code> 后面的 <code>Generator</code> 函数（没有 <code>return</code> 语句时），等同于在 <code>Generator</code> 函数内部，部署一个 <code>for...of</code> 循环反之，在有 <code>return</code> 语句时，则需要用 <code>var value = yield* iterator</code> 的形式获取 <code>return</code> 语句的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实际上，任何数据结构只要有 <code>Iterator</code> 接口，就可以被 <code>yield*</code> 遍历</p>
</li>
</ul>
<h2><span id="generator-函数的异步调用">✎ Generator 函数的异步调用</span></h2>
<h3><span id="传统方法">传统方法</span></h3>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<h3><span id="基本概念">基本概念</span></h3>
<blockquote>
<p>所谓&quot;异步&quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，
先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。
相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着</p>
</blockquote>
<h3><span id="协程">协程</span></h3>
<blockquote>
<p>&quot;协程&quot;（<code>coroutine</code>），意思是多个线程互相协作，完成异步任务</p>
</blockquote>
<p>运行流程大致如下：</p>
<ol>
<li>协程 <code>A</code> 开始执行</li>
<li>协程 <code>A</code> 执行到一半，进入暂停，执行权转移到协程 <code>B</code></li>
<li>（一段时间后）协程 <code>B</code> 交还执行权</li>
<li>协程 <code>A</code> 恢复执行</li>
</ol>
<h3><span id="thunk-函数">Thunk 函数</span></h3>
<ul>
<li>
<p>编译器的 “传名调用” 实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <code>Thunk</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="co-模块">co 模块</span></h3>
<ul>
<li>
<p>用于 <code>Generator</code> 函数的自动执行</p>
</li>
<li>
<p><code>co</code> 模块其实就是将两种自动执行器（<code>Thunk</code> 函数和 <code>Promise</code> 对象），包装成一个模块。使用 <code>co</code> 的前提条件是，<code>Generator</code> 函数的yield命令后面，只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象。如果数组或对象的成员，全部都是 <code>Promise</code> 对象，也可以使用 <code>co</code></p>
</li>
</ul>
<h2><span id="async-函数">✎ async 函数</span></h2>
<h3><span id="基本用法">基本用法</span></h3>
<blockquote>
<p><code>async</code> 函数返回一个 <code>Promise</code> 对象，可以使用 <code>then</code> 方法添加回调函数。
当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">val, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tm = <span class="keyword">await</span> timeout(delay);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'world'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;</span></span><br><span class="line"><span class="comment">// world // after 500ms</span></span><br></pre></td></tr></table></figure>
<h3><span id="语法">语法</span></h3>
<ul>
<li>
<p><code>async</code> 函数返回一个 <code>Promise</code> 对象</p>
</li>
<li>
<p><code>async</code> 函数内部 <code>return</code> 语句返回的值，会成为 <code>then</code> 方法回调函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>async</code> 函数返回的 <code>Promise</code> 对象，必须等到内部所有 <code>await</code> 命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到 <code>return</code> 语句或者 <em>抛出错误</em> 。也就是说，只有 <code>async</code> 函数内部的异步操作执行完，才会执行 <code>then</code> 方法指定的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 <code>getTitle</code> 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 <code>then</code> 方法里面的 <code>console.log</code></p>
</li>
<li>
<p>正常情况下，<code>await</code> 命令后面是一个 <code>Promise</code> 对象。如果不是，会被转成一个立即 <code>resolve</code> 的 <code>Promise</code> 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只要一个 <code>await</code> 语句后面的 <code>Promise</code> 变为 <code>reject</code>，那么整个 <code>async</code> 函数都会中断执行。（个人理解： <code>reject()</code> 改变了整个函数 <code>async</code> 返回的 <code>promise</code> 对象的状态（rejected），抛出了异常，从而中断函数体的继续执行）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法是，将第一个 <code>await</code> 放在 <code>try...catch</code> 里面，或用 <code>catch</code> 方法处理异常</p>
</li>
</ul>
<h3><span id="使用注意点">使用注意点</span></h3>
<ol>
<li>
<p><code>await</code> 命令后面的 <code>Promise</code> 对象，运行结果可能是 <code>rejected</code>，所以最好把 <code>await</code> 命令放在 <code>try...catch</code> 代码块中</p>
</li>
<li>
<p>多个 <code>await</code> 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>await</code> 命令只能用在 <code>async</code> 函数之中，如果用在普通函数，就会报错</p>
</li>
</ol>
<h3><span id="async-函数的实现原理">async 函数的实现原理</span></h3>
<blockquote>
<p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 <code>async</code> 函数都可以写成上面的第二种形式，其中的 <code>spawn</code> 函数就是自动执行器</p>
<h2><span id="class-的基本语法">✎ Class 的基本语法</span></h2>
<h3><span id="基本语法">基本语法</span></h3>
<ol>
<li>类的方法都定义在 <code>prototype</code> 对象上面</li>
<li>类的内部所有定义的方法，都是<strong>不可枚举</strong>的（<code>non-enumerable</code>）</li>
<li>类和模块的内部，默认就是<strong>严格模式</strong>，所以不需要使用 <code>use strict</code> 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用</li>
</ol>
<h3><span id="constructor-方法">constructor 方法</span></h3>
<ul>
<li>
<p><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有 <code>constructor</code> 方法，如果没有显式定义，一个空的 <code>constructor</code> 方法会被默认添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类必须使用 <code>new</code> 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 <code>new</code> 也可以执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="不存在变量提升">不存在变量提升</span></h3>
<ul>
<li>
<p>类<strong>不存在</strong>变量提升（<code>hoist</code>），这一点与 <code>ES5</code> 完全不同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="class-的静态方法">Class 的静态方法</span></h3>
<ul>
<li>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为 “静态方法”。注意： 如果静态方法包含 <code>this</code> 关键字，这个 <code>this</code> 指的是<strong>类</strong>，而不是实例</p>
</li>
<li>
<p>静态方法可以与非静态方法重名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar () &#123;</span><br><span class="line">    <span class="keyword">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>父类的静态方法，可以被子类继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="class-的静态属性和实例属性">Class 的静态属性和实例属性</span></h3>
<ul>
<li>
<p><code>ES6</code> 明确规定，<code>Class</code> 内部只有<strong>静态方法</strong>，没有静态属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写法一 - 无效</span></span><br><span class="line">  prop: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写法二 - 无效</span></span><br><span class="line">  <span class="keyword">static</span> prop: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>; <span class="comment">// 有效</span></span><br><span class="line">Foo.prop; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="newtarget-属性">new.target 属性</span></h3>
<ul>
<li>
<p><code>new.target</code> 属性，该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数。如果构造函数不是通过 <code>new</code> 命令调用的，<code>new.target</code> 会返回 <code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的</p>
</li>
<li>
<p>子类继承父类时，<code>new.target</code> 会返回<strong>子类</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name); <span class="comment">// Square</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="class-的继承">✎ Class 的继承</span></h2>
<h3><span id="简介">简介</span></h3>
<ul>
<li>
<p>子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，然后对其进行加工。如果不调用 <code>super</code> 方法，子类就得不到 <code>this</code> 对象</p>
</li>
<li>
<p><code>ES5</code> 的继承，实质是先创造<strong>子类</strong>的实例对象 <code>this</code>，然后再将<strong>父类</strong>的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。<code>ES6</code> 的继承机制完全不同，实质是先创造<strong>父类</strong>的实例对象 <code>this</code>（所以必须先调用 <code>super</code> 方法），然后再用子类的构造函数修改 <code>this</code></p>
</li>
<li>
<p>在子类的构造函数中，只有调用 <code>super()</code> 之后，才可以使用 <code>this</code> 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果子类没有定义 <code>constructor</code> 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 <code>constructor</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="super-关键字">super 关键字</span></h3>
<ul>
<li>
<p><code>super</code> 这个关键字，既可以当作函数使用，也可以当作对象使用：</p>
<ol>
<li>
<p><code>super</code> 作为<strong>函数</strong>调用时，代表父类的构造函数。<code>ES6</code> 要求，子类的构造函数必须执行一次 <code>super</code> 函数</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A(); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B(); <span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>super</code> 虽然代表了父类A的构造函数，但是返回的是子类B的实例，
即 <code>super</code> 内部的 <code>this</code> 指的是B，因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this)</code></p>
<blockquote>
<p>作为函数时，<code>super()</code> 只能用在<strong>子类</strong>的<strong>构造函数</strong>之中，用在其他地方就会报错</p>
</blockquote>
</li>
<li>
<p><code>super</code> 作为<strong>对象</strong>时，在普通方法中，指向父类的<strong>原型对象</strong>；在静态方法中，指向父类</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>注意，使用 <code>super</code> 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3><span id="类的-prototype-属性和-__proto__-属性">类的 <code>prototype</code> 属性和 <code>__proto__</code> 属性</span></h3>
<p>类的继承是按照下面的模式实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<p>可以这样理解：</p>
<ol>
<li>作为一个对象，子类（B）的原型（<code>__proto__</code>属性）是父类（A）；</li>
<li>作为一个构造函数，子类（B）的原型对象（<code>prototype</code> 属性）是父类的原型对象（<code>prototype</code> 属性）的实例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure>
<h3><span id="原生构造函数的继承">原生构造函数的继承</span></h3>
<ul>
<li>
<p><code>ES6</code> 可以自定义原生数据结构（比如 <code>Array</code>、<code>String</code> 等）的子类，这是 <code>ES5</code> 无法做到的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>注意：继承 <code>Object</code> 的子类，有一个 <strong>行为差异</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewObj</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> NewObj(&#123;<span class="attr">attr</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">o.attr === <span class="literal">true</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>NewObj</code> 继承了 <code>Object</code>，但是无法通过 <code>super</code> 方法向父类 <code>Object</code> 传参。
这是因为 <code>ES6</code> 改变了 <code>Object</code> 构造函数的行为，一旦发现 <code>Object</code> 方法不是通过 <code>new Object()</code> 这种形式调用，<code>ES6</code> 规定 <code>Object</code> 构造函数会忽略参数</p>
</li>
</ul>
<h2><span id="decorator">✎ Decorator</span></h2>
<p><a href="//es6.ruanyifeng.com/#docs/decorator">提案</a></p>
<h2><span id="module-的语法">✎ Module 的语法</span></h2>
<h3><span id="概述">概述</span></h3>
<ul>
<li>
<p><code>ES6</code> 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure>
<p>这种加载称为 “编译时加载” 或者 静态加载，即 <code>ES6</code> 可以在编译时就完成模块加载，效率要比 <code>CommonJS</code> 模块的加载方式高。
当然，这也导致了没法引用 <code>ES6</code> 模块本身，因为它不是对象</p>
</li>
<li>
<p><code>ES6</code> 模块的好处：</p>
<ul>
<li>静态加载，编译时就能确定模块的依赖关系，以及输入和输出的变量</li>
<li>不再需要 <code>UMD</code> 模块格式了，将来服务器和浏览器都会支持 <code>ES6</code> 模块格式。目前，通过各种工具库，其实已经做到了这一点</li>
<li>将来浏览器的新 <code>API</code> 就能用模块格式提供，不再必须做成全局变量或者 <code>navigator</code> 对象的属性</li>
<li>不再需要对象作为命名空间（比如 <code>Math</code> 对象），未来这些功能可以通过模块提供</li>
</ul>
</li>
</ul>
<h3><span id="严格模式">严格模式</span></h3>
<ul>
<li>
<p><code>ES6</code> 的模块自动采用严格模式，不管你有没有在模块头部加上 <code>&quot;use strict&quot;;</code></p>
</li>
<li>
<p><code>ES6</code> 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>，即不应该在顶层代码使用 <code>this</code></p>
</li>
<li>
<p><strong>严格模式</strong> 主要有以下限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用 <code>with</code> 语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用 <code>前缀 0</code> 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量 <code>delete variable</code>，会报错，只能删除属性 <code>delete global[prop]</code></li>
<li><code>eval</code> 不会在它的外层作用域引入变量</li>
<li><code>eval</code> 和 <code>arguments</code> 不能被重新赋值</li>
<li><code>arguments</code> 不会自动反映函数参数的变化</li>
<li>不能使用 <code>arguments.callee</code></li>
<li>不能使用 <code>arguments.caller</code></li>
<li>禁止 <code>this</code> 指向全局对象（<code>ES6</code> 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>，即不应该在顶层代码使用 <code>this</code>）</li>
<li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</li>
<li>增加了保留字（比如 <code>protected</code>、<code>static</code> 和 <code>interface</code>）</li>
</ul>
</li>
</ul>
<h3><span id="export-命令">export 命令</span></h3>
<ul>
<li>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量</p>
<blockquote>
<p><strong>注意</strong>： <code>export</code> 命令规定的是对外的<strong>接口</strong>，必须与模块内部的变量建立一一对应关系</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都会报错，因为没有提供对外的接口。
第一种写法直接输出 <code>1</code>，
第二种写法通过变量 <code>m</code>，还是直接输出 <code>1</code>。
<code>1</code> 只是一个值，不是接口。正确的写法是下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure>
<p>上面三种写法都是正确的，规定了对外的接口 <code>m</code>。其他脚本可以通过这个接口，取到值 <code>1</code>。
它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系</p>
</li>
<li>
<p><code>export</code> 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。即：<code>ES6</code> 模块输出的是值的<strong>引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码输出变量 <code>foo</code>，值为 <code>bar</code>，<code>500</code> 毫秒之后变成 <code>baz</code>。</p>
<p>这一点与 <code>CommonJS</code> 规范完全不同。<code>CommonJS</code> 模块输出的是值的缓存，不存在动态更新</p>
</li>
</ul>
<h3><span id="import-命令">import 命令</span></h3>
<ul>
<li>
<p><code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行。<code>import</code> 命令是编译阶段执行的，在代码运行之前</p>
</li>
<li>
<p>由于 <code>import</code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果多次重复执行同一句 <code>import</code> 语句，那么<strong>只会执行一次</strong>，而不会执行多次（<code>Singleton</code> 模式）</p>
</li>
</ul>
<h3><span id="模块的整体加载">模块的整体加载</span></h3>
<ul>
<li>
<p>用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>
<p>注意，模块整体加载所在的那个对象（上例是 <code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是<strong>不允许</strong>的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3><span id="export-default-命令">export default 命令</span></h3>
<ul>
<li>
<p><code>export default</code> 命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此 <code>export default</code> 命令只能使用<strong>一次</strong>所以，<code>import</code> 命令后面才不用加大括号，因为只可能对应一个方法</p>
</li>
<li>
<p>本质上，<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字（<code>export default</code> 本质是将该命令后面的值，赋给 <code>default</code> 变量以后再默认）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from 'modules';</span></span><br></pre></td></tr></table></figure>
<h2><span id="module-的加载实现">✎ Module 的加载实现</span></h2>
<h3><span id="浏览器加载">浏览器加载</span></h3>
<ul>
<li>
<p><code>defer</code> 是 “渲染完再执行”，<code>async</code> 是 “下载完就执行”</p>
<blockquote>
<p><code>defer</code> 要等到整个页面在内存中正常渲染结束（<code>DOM</code> 结构完全生成，以及其他脚本执行完成），才会执行
<code>async</code> 是一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染
如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载，而多个 <code>async</code> 脚本是不能保证加载顺序的</p>
</blockquote>
</li>
<li>
<p>浏览器加载 <code>ES6</code> 模块，也使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性</p>
</li>
<li>
<p>浏览器对于带有 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 <code>&lt;script&gt;</code> 标签的 <code>defer</code> 属性</p>
</li>
<li>
<p>对于<strong>外部</strong>的模块脚本，需要注意：</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见</li>
<li>模块脚本自动采用<strong>严格模式</strong>，不管有没有声明 <code>use strict;</code></li>
<li>模块之中，可以使用 <code>import</code> 命令加载其他模块（.js后缀<strong>不可</strong>省略，需要提供绝对 URL 或相对 URL），也可以使用 <code>export</code> 命令输出对外接口</li>
<li>模块之中，顶层的 <code>this</code> 关键字返回 <code>undefined</code>，而不是指向 <code>window</code>。也就是说，在模块顶层使用 <code>this</code> 关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次</li>
</ul>
</li>
</ul>
<h3><span id="es6-模块与-commonjs-模块的差异">ES6 模块与 CommonJS 模块的差异</span></h3>
<h4><span id="对比">对比</span></h4>
<ul>
<li><code>CommonJS</code> 模块输出的是一个值的拷贝，<code>ES6</code> 模块输出的是值的引用</li>
<li><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口</li>
</ul>
<blockquote>
<p><code>ES6</code> 模块的运行机制与 <code>CommonJS</code> 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 <code>import</code>，就会生成一个<strong>只读引用</strong>。
等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
换句话说，<code>ES6</code> 的 <code>import</code> 有点像 <code>Unix</code> 系统的 “符号连接”，原始值变了，<code>import</code> 加载的值也会跟着变。
因此，<code>ES6</code> 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4><span id="commonjs-模块的加载原理">CommonJS 模块的加载原理</span></h4>
<blockquote>
<p><code>CommonJS</code> 的一个模块，就是一个脚本文件。<code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后需要用到这个模块的时候，就会到 <code>exports</code> 属性上面取值。
即使再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。
也就是说，<code>CommonJS</code> 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存</p>
<h3><span id="node-加载">Node 加载</span></h3>
<h4><span id="内部变量">内部变量</span></h4>
<blockquote>
<p><code>ES6</code> 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。
为了达到这个目标，<code>Node</code> 规定 <code>ES6</code> 模块之中不能使用 <code>CommonJS</code> 模块的特有的一些内部变量</p>
</blockquote>
<ul>
<li>
<p>首先，就是 <code>this</code> 关键字：</p>
<ul>
<li><code>ES6</code> 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code></li>
<li><code>CommonJS</code> 模块的顶层 <code>this</code> 指向当前模块</li>
</ul>
</li>
<li>
<p>其次，以下这些顶层变量在 <code>ES6</code> 模块之中都是<strong>不存在</strong>的：</p>
<ul>
<li><code>arguments</code></li>
<li><code>require</code></li>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>__filename</code></li>
<li><code>__dirname</code></li>
</ul>
</li>
</ul>
<h4><span id="es6-模块加载-commonjs-模块">ES6 模块加载 CommonJS 模块</span></h4>
<blockquote>
<p><code>CommonJS</code> 模块的输出都定义在 <code>module.exports</code> 这个属性上面。
<code>Node</code> 的 <code>import</code> 命令加载 <code>CommonJS</code> 模块，<code>Node</code> 会自动将 <code>module.exports</code> 属性，当作模块的默认输出，即等同于 <code>export default xxx</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">bar.default(); <span class="comment">// 2</span></span><br><span class="line">bar(); <span class="comment">// throws, bar is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bar</code> 本身是一个对象，不能当作函数调用，只能通过 <code>bar.default</code> 调用</p>
<h4><span id="commonjs-模块加载-es6-模块">CommonJS 模块加载 ES6 模块</span></h4>
<blockquote>
<p><code>CommonJS</code> 模块加载 <code>ES6</code> 模块，不能使用 <code>require</code> 命令，而要使用 <code>import()</code> 函数。
<code>ES6</code> 模块的所有输出接口，会成为输入对象的属性</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = &#123; <span class="attr">bar</span>:<span class="string">'my-default'</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get f() &#123;return f;&#125;</span></span><br><span class="line"><span class="comment">//   get c() &#123;return c;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3><span id="循环加载">循环加载</span></h3>
<h4><span id="commonjs-模块的循环加载">CommonJS 模块的循环加载</span></h4>
<blockquote>
<p><code>CommonJS</code> 模块的重要特性是加载时执行，即脚本代码在 <code>require</code> 的时候，就会全部执行。
一旦出现某个模块被&quot;循环加载&quot;，就只输出已经执行的部分，还未执行的部分不会输出</p>
</blockquote>
<h4><span id="es6-模块的循环加载">ES6 模块的循环加载</span></h4>
<blockquote>
<p><code>ES6</code> 模块是动态引用，如果使用 <code>import</code> 从一个模块加载变量（即 <code>import foo from 'foo'</code>），
那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</p>
</blockquote>
<h2><span id="编程风格">✎ 编程风格</span></h2>
<p><a href="//github.com/airbnb/javascript">Airbnb JavaScript 风格规范</a></p>
<h2><span id="读懂规格">✎ 读懂规格</span></h2>
<p><a href="//www.ecma-international.org/ecma-262/6.0/">ECMA 国际标准组织的官方网站</a></p>
<h2><span id="arraybuffer">✎ ArrayBuffer</span></h2>
<blockquote>
<p><code>ArrayBuffer</code> 对象、<code>TypedArray</code> 视图和 <code>DataView</code> 视图是 JavaScript 操作二进制数据的一个接口</p>
</blockquote>
<p>二进制数组由三类对象组成：</p>
<ol>
<li>
<p><code>ArrayBuffer</code> 对象：代表内存之中的一段二进制数据，可以通过 “视图” 进行操作。“视图” 部署了数组接口，这意味着，可以用数组的方法操作内存</p>
</li>
<li>
<p><code>TypedArray</code> 视图：共包括 9 种类型的视图，比如 <code>Uint8Array</code>（无符号 8 位整数）数组视图, <code>Int16Array</code>（16 位整数）数组视图, <code>Float32Array</code>（32 位浮点数）数组视图等等</p>
</li>
<li>
<p><code>DataView</code> 视图：可以自定义复合格式的视图，比如第一个字节是 <code>Uint8</code>（无符号 8 位整数）、第二、三个字节是 <code>Int16</code>（16 位整数）、第四个字节开始是 <code>Float32</code>（32 位浮点数）等等，此外还可以自定义字节序列</p>
</li>
</ol>
<p>简单说，<code>ArrayBuffer</code> 对象代表原始的二进制数据，<code>TypedArray</code> 视图用来读写简单类型的二进制数据，<code>DataView</code> 视图用来读写复杂类型的二进制数据。</p>
<blockquote>
<p>注意：二进制数组并不是真正的数组，而是类似数组的对象</p>
</blockquote>
<p>很多浏览器操作的 <code>API</code>，用到了二进制数组操作二进制数据，下面是其中的几个：</p>
<ul>
<li><code>File API</code></li>
<li><code>XMLHttpRequest</code></li>
<li><code>Fetch API</code></li>
<li><code>Canvas</code></li>
<li><code>WebSockets</code></li>
</ul>
<h2><span id="参考链接">✎ 参考链接</span></h2>
<p><a href="//es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 语言精粹：异步模型]]></title>
      <url>https://blog.tiy.xyz/posts/2018/2255145150/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>JavaScript 是门非阻塞单线程语言，因为在最初 JavaScript 就是为了和浏览器交互而诞生的。
JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<a id="more"></a>
<h2><span id="基本概念">基本概念</span></h2>
<ul>
<li>
<p><strong>主线程</strong>：Javascript 执行引擎，负责程序本身的运行</p>
</li>
<li>
<p><strong>同步任务</strong>：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p>
</li>
<li>
<p><strong>异步任务</strong>：不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务。</p>
</li>
<li>
<p><strong>回调函数（Callback）</strong>：那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
</li>
</ul>
<h2><span id="任务队列task-queue">任务队列（Task Queue）</span></h2>
<p>任务队列，是包含多个事件的队列（也可以理解成消息的队列），是一个先进先出（FIFO）的有序的数据结构。比如IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。</p>
<p>任务队列中包含以下任务：</p>
<ul>
<li><code>Events</code>：在事件目标上发送事件对象。注意，不是所有的事件都从任务队列中发送，有许多是在别的任务中发送的。</li>
<li><code>Parsing</code>：HTML parser 标记化转换任务</li>
<li><code>Callbacks</code>：回调由一个专用任务调度</li>
<li><code>Using a resource</code>：获取网络资源</li>
<li><code>Reacting to DOM manipulation</code>：DOM操作响应。比如为元素添加子节点</li>
</ul>
<h2><span id="事件循环event-loop">事件循环（Event Loop）</span></h2>
<h3><span id="概念">概念</span></h3>
<p>JavaScript 执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程。<a href="https://www.w3.org/TR/html5/webappapis.html#event-loop" target="_blank" rel="noopener">W3C规范</a></p>
<p><a href="//en.wikipedia.org/wiki/Event_loop">Wikipedia</a> 定义:</p>
<blockquote>
<p>In computer science, the event loop, message dispatcher, message loop, message pump, or run loop is a programming construct that waits for and dispatches events or messages in a program.</p>
</blockquote>
<p><a href="//html.spec.whatwg.org/multipage/webappapis.html#event-loop">WHATWG</a> 定义：</p>
<blockquote>
<p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. There are two kinds of event loops: those for browsing contexts, and those for workers.</p>
</blockquote>
<p>小结：</p>
<ul>
<li>
<p>事件循环（Event Loop）是一个程序结构，用于等待和发送消息和事件。</p>
</li>
<li>
<p>事件循环有 2 种：</p>
<ul>
<li>Browsing contexts</li>
<li>Workers</li>
</ul>
</li>
</ul>
<h3><span id="处理模型">处理模型</span></h3>
<p>规范：</p>
<p><a href="//html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">Event loop processing model - WHATWG</a></p>
<p>事件循环示意图：</p>
<p><img src="js-event-loop.png" alt="JavaScript 事件循环模型"></p>
<p>关键点：</p>
<ul>
<li>
<p>主线程运行的时候，产生堆（heap）和栈（stack）。栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）</p>
</li>
<li>
<p>执行栈（stack）中的代码（同步任务），总是在读取&quot;任务队列&quot;（异步任务）之前执行</p>
</li>
<li>
<p>每个浏览器环境，至多有一个事件循环（event loop）</p>
</li>
<li>
<p>一个事件循环可以有1个或多个任务队列（task queue）</p>
</li>
</ul>
<h2><span id="定时器settimeout">定时器：setTimeout</span></h2>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'timeout'</span>) &#125;</span><br><span class="line"><span class="keyword">const</span> delay = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> timeoutID = setTimeout(fn, delay)</span><br></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>
<p>返回值 <code>timeoutID</code> 是一个<strong>正整数</strong>，表示定时器的编号，是计划执行代码的唯一标识符。这个值可以传递给 <code>clearTimeout()</code> 来取消该定时</p>
</li>
<li>
<p>当在代码中调用 <code>setTimeout()</code> 方法时，注册的延时方法会交由浏览器内核其他模块（<code>timer</code> 模块，以 <code>Webkit</code> 为例，是 <code>Webcore</code> 模块提供的）处理。当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，<strong>与执行引擎主线程独立</strong></p>
</li>
<li>
<p><code>fn</code> 可为字符串，但不推荐使用</p>
</li>
<li>
<p>关于延时 <code>delay</code>：</p>
<ul>
<li>
<p>单位为 <code>ms</code></p>
</li>
<li>
<p>如果省略该参数，<code>delay</code> 取默认值 <code>0</code></p>
</li>
<li>
<p>取值 <code>0</code> 的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行</p>
</li>
<li>
<p>最小值：HTML5 标准规定了 <code>setTimeout()</code> 的第二个参数的最小值（最短间隔），不得低于 <code>4</code> 毫秒，如果低于这个值，就会使用最小值</p>
</li>
</ul>
<blockquote>
<p>一直以来，不同浏览器中出现这种最小延迟的情况有所不同（例如Firefox） - 从其他地方调用了 <code>setInterval()</code>，或者在嵌套函数调用<code>setTimeout()</code> 时（嵌套级别达到特定深度时），都会出现超时延迟。
除了&quot;最小延时&quot;之外，定时器仍然有可能因为当前页面（或者操作系统/浏览器本身）被其他任务占用导致延时。</p>
</blockquote>
<ul>
<li>
<p>最大值：浏览器包括 IE, Chrome, Safari, Firefox 以 32 个 bit 字节存储整数。这就会导致如果一个整数大于 <code>2147483647</code> （<code>2^31 - 1</code>，大约24.8 天）时就会溢出，导致定时器将会被<strong>立即执行</strong></p>
</li>
<li>
<p>比 delay 为 0 更小的延时，采用 <code>window.postMessage()</code>，参考 <a href="//dbaron.org/log/20100309-faster-timeouts">setTimeout with a shorter delay</a></p>
</li>
</ul>
</li>
</ul>
<h2><span id="重排reflow与重绘repaint">重排（Reflow）与重绘（Repaint）</span></h2>
<p>重排和重绘其实和 Event loop 有关，在事件循环处理模型中的 “Update the rendering” 环节中，按照以下<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">流程</a>处理：</p>
<ol>
<li>当 Event loop 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。如果浏览器是 60Hz 的刷新率，约每 <code>16ms</code> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code> 回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</li>
</ol>
<h2><span id="任务task">任务（Task）</span></h2>
<h3><span id="概念">概念</span></h3>
<ul>
<li>
<p>宏任务（macro-task）：代指任务（Task），包含：</p>
<ul>
<li><code>script(整体代码)</code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>I/O</code></li>
<li><code>UI rendering</code></li>
</ul>
</li>
<li>
<p>微任务（micro-task）：在 ES2015 规范中称为 Job，可理解为更小粒度的单项工作。包含：</p>
<ul>
<li><code>Promises</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code></li>
<li><code>process.nextTick</code></li>
</ul>
</li>
</ul>
<p>[注：为了明显区分 macrotask 和 microtask，本文一般添加加短横线]</p>
<h3><span id="事件循环如何处理任务tasks-和-microtasks">事件循环如何处理任务（tasks 和 microtasks）</span></h3>
<ul>
<li>
<p>每个线程有自己的事件循环，所以每个 web worker 有自己的，所以它才可以<strong>独立执行</strong>。然而，所有同属一个 origin 的 windows 共享一个事件循环，所以它们可以<strong>同步交流</strong></p>
</li>
<li>
<p>事件循环不间断在跑，执行任何进入队列的 task</p>
</li>
<li>
<p>一个事件循环可以有多个 task source，每个 task source 保证自己的任务列表的执行顺序，但由浏览器在（事件循环的）每轮中挑选某个 task source 的 task</p>
</li>
<li>
<p>任务是被有序计划的（scheduled），所以浏览器可以从内部到JS/DOM，保证动作按序发生。在 tasks 之间，浏览器可能会 render updates</p>
</li>
<li>
<p>微任务（micro-tasks）也是被有序计划好的（scheduled），经常是为需要直接在<strong>当前脚本执行完后立即发生</strong>的事，比如 async 某些动作但不必承担新开 task 的弊端。micro-task queue 在回调之后执行，只要没有其它JS在执行中，并且在每个 task 的结尾。micro-task 中添加（嵌套）的 micro-task 也被添加到 micro-task queue 的末尾并处理。micro-task 包括 Mutation Observer callbacks 和 Promise callbacks</p>
</li>
<li>
<p>click, ajax, setTimeout 的回调是都是 task, 同时，包裹在一个 script 标签中的js代码也是一个 task 确切说是 macro-task</p>
</li>
</ul>
<h3><span id="执行顺序">执行顺序</span></h3>
<ol>
<li>JavaScript 引擎首先从 macro-task queue 中取出第一个任务（同步任务），并执行；</li>
<li>执行完毕后，将 micro-task queue 中的所有任务取出，按顺序全部执行；</li>
<li>必要的话渲染 UI（UI rendering）；</li>
<li>然后再从 macro-task queue 中取下一个，并执行；</li>
<li>执行完毕后，再次将 micro-task queue 中的全部取出；</li>
<li>循环往复，直到两个 queue 中的任务都取完。</li>
</ol>
<blockquote>
<p>在一个事件循环的周期(cycle)中一个 (macro)task 应该从 macrotask 队列开始执行。当这个 macrotask 结束后，所有的 microtasks 将在同一个 cycle 中执行。<strong>在 microtasks 执行时还可以加入更多的 microtask</strong>，然后一个一个的执行，直到 microtask 队列清空。</p>
</blockquote>
<h3><span id="如何选择">如何选择</span></h3>
<p>基本来说，当我们想<strong>以同步的方式来处理异步任务</strong>时候就用 micro-task（比如我们需要直接在某段代码后就去执行某个任务，就像 <code>Promise</code> 一样）。</p>
<p>其他情况就直接用 macro-task</p>
<h3><span id="实战演练">实战演练</span></h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'task start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setInterval'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout 1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'promise 3'</span>) &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'promise 4'</span>) &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout 2'</span>)</span><br><span class="line">        <span class="built_in">Promise</span>.resolve()</span><br><span class="line">          .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'promise 5'</span>) &#125;)</span><br><span class="line">          .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'promise 6'</span>) &#125;)</span><br><span class="line">          .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; clearInterval(interval) &#125;)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>) &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'task end'</span>)</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<p>将 macro-task 和 micro-task 看作是2个队列，不断的清空入栈执行：</p>
<ol>
<li>setInterval 和 setTimeout 1 被加入到 task，promise 1 和 promise 2 被加入到 micro-task</li>
<li>清空 micro-task，打印 promise 1 和 promise 2，执行 task 队列，打印 setInterval 和 setTimeout 1</li>
<li>setInterval 被加入到 task，promise 3 和 promise 4 被加入到 micro-task，setTimeout 被加入到 task</li>
<li>清空 micro-task，打印 promise 3和 promise 4，执行 task 队列，打印 setInterval，setTimeout 2</li>
<li>setInterval 被加入到 task，promise 5 和 promise 6 被加入到 micro-task</li>
<li>清空 micro-task，打印 promise 5 和promise 6，clearInterval</li>
</ol>
<p>结果：</p>
<p><img src="js-answer-tasks.jpg" alt="JavaScript 事件循环题解"></p>
<p>注：实际在 Chrome 控制台执行时，期间同时执行 <code>setInterval</code> 代码 <strong>2次</strong></p>
<h2><span id="参考资料">参考资料</span></h2>
<ul>
<li><a href="//developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">window.setTimeout - MDN</a></li>
<li><a href="//www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="//www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/">【转向Javascript系列】从setTimeout说事件循环模型</a></li>
<li><a href="//github.com/creeperyang/blog/issues/21">从Promise来看JavaScript中的Event Loop、Tasks和Microtasks</a></li>
<li><a href="//www.jianshu.com/p/3ed992529cfc">Macrotask Queue和Microtask Quque</a></li>
<li><a href="//github.com/ccforward/cc/issues/48">理解事件循环二(macrotask和microtask)</a></li>
<li><a href="//jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li><a href="//html.spec.whatwg.org/multipage/webappapis.html#event-loops">Event-Loops - Perform a microtask checkpoint</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 语言精粹：原型与继承]]></title>
      <url>https://blog.tiy.xyz/posts/2018/1809288136/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<a id="more"></a>
<h2><span id="原型链">原型链</span></h2>
<p><img src="js-prototype.png" alt="JavaScript 原型链"></p>
<p>JavaScript 原型链</p>
<blockquote>
<p>基本上所有函数都含有 <code>prototype</code> 原型属性，除了 <code>Function.prototype.bind()</code> 方法<strong>生成的</strong>函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Function</span>.prototype.bind()</span><br><span class="line"><span class="keyword">typeof</span> foo <span class="comment">// -&gt; "function"</span></span><br><span class="line">foo.prototype === <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>
<h2><span id="new-过程">new 过程</span></h2>
<ol>
<li>
<p>新建空对象 <code>{}</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置对象 <code>constructor</code> 属性为构造函数，根据引擎环境设置原型属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ = Fn.prototype</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用新对象调用函数构造器，上下文 <code>this</code> 被指向该对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fn.call(obj)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回新对象（引用地址）。</p>
<p>注意：若构造函数最终返回值类型为基本数据类型（<code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>），则 <code>new</code> 之后返回刚刚创建的实例对象；若构造函数返回值类型为引用类型，则返回这个引用值</p>
</li>
</ol>
<h2><span id="functionproto-functionprototype">Function.<strong>proto</strong> === Function.prototype</span></h2>
<p>如图：</p>
<p><img src="js-prototype-1.jpg" alt="Function.prototype"></p>
<p>解析：</p>
<ul>
<li><code>Object.prototype</code> 由引擎创建，不是由 <code>Object()</code> 函数创建。所有实例都是对象，但是对象不一定都是实例。</li>
<li><code>Function.prototype</code> 也由引擎创建。首先引擎创建了 <code>Object.prototype</code> ，然后创建了 <code>Function.prototype</code> ，并且通过 <code>__proto__</code> 将两者联系了起来</li>
<li>不是所有函数都是 <code>new Function()</code> 产生的。有了 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。</li>
</ul>
<p><img src="js-prototype-2.jpg" alt="Function.prototype"></p>
<h2><span id="实现继承">实现继承</span></h2>
<p>ES5 写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Sub,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Sub()</span><br><span class="line">s.getNumber() <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>ES6 写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">  logTime () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Time: <span class="subst">$&#123;<span class="keyword">this</span>.getTime()&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myDate = <span class="keyword">new</span> SubDate()</span><br><span class="line">myDate.getTime() <span class="comment">// -&gt; xxxxxxxxxxxxx</span></span><br><span class="line">myDate.logTime() <span class="comment">// -&gt; Time: xxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure>
<h2><span id="参考资料">[参考资料]</span></h2>
<ul>
<li><a href="https://github.com/KieSun/Blog/issues/2" target="_blank" rel="noopener">深度解析原型中的各个难点</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 语言精粹：类型转换]]></title>
      <url>https://blog.tiy.xyz/posts/2018/1778481141/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>JavaScript 期望使用一个比如布尔值的时候，会对数值进行转换，真值会被当成 true，假值会被当成 false。其他情况，JavaScript 引擎会根据上下文需要对其进行必要的转换</p>
<a id="more"></a>
<h2><span id="类型转换">类型转换</span></h2>
<p>表：JavaScript 类型转换</p>
<table>
<thead>
<tr>
<th>值</th>
<th>转换为：字符串</th>
<th>数字</th>
<th>布尔值</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>&quot;undefined&quot;</td>
<td>NaN</td>
<td>false</td>
<td>throws TypeError</td>
</tr>
<tr>
<td>null</td>
<td>&quot;null&quot;</td>
<td><strong>0</strong></td>
<td>false</td>
<td>throws TypeError</td>
</tr>
<tr>
<td>true</td>
<td>&quot;true&quot;</td>
<td><strong>1</strong></td>
<td></td>
<td>new Boolean(true)</td>
</tr>
<tr>
<td>false</td>
<td>&quot;false&quot;</td>
<td><strong>0</strong></td>
<td></td>
<td>new Boolean(false)</td>
</tr>
<tr>
<td>&quot;&quot;（空字符串）</td>
<td></td>
<td><strong>0</strong></td>
<td>false</td>
<td>new String(&quot;&quot;)</td>
</tr>
<tr>
<td>&quot;1.2&quot;（非空，数字）</td>
<td></td>
<td>1.2</td>
<td>true</td>
<td>new String(&quot;1.2&quot;)</td>
</tr>
<tr>
<td>&quot;one&quot;（非空，非数字）</td>
<td></td>
<td>NaN</td>
<td>true</td>
<td>new String(&quot;one&quot;)</td>
</tr>
<tr>
<td>0</td>
<td>&quot;0&quot;</td>
<td></td>
<td>false</td>
<td>new Number(0)</td>
</tr>
<tr>
<td>-0</td>
<td>&quot;0&quot;</td>
<td></td>
<td>false</td>
<td>new Number(-0)</td>
</tr>
<tr>
<td>NaN</td>
<td>&quot;NaN&quot;</td>
<td></td>
<td>false</td>
<td>new Number(NaN)</td>
</tr>
<tr>
<td>Infinity</td>
<td>&quot;Infinity&quot;</td>
<td></td>
<td>true</td>
<td>new Number(Infinity)</td>
</tr>
<tr>
<td>-Infinity</td>
<td>&quot;-Infinity&quot;</td>
<td></td>
<td>true</td>
<td>new Number(-Infinity)</td>
</tr>
<tr>
<td>1（无穷大，非零）</td>
<td>&quot;1&quot;</td>
<td></td>
<td>true</td>
<td>new Number(1)</td>
</tr>
<tr>
<td>{}（任意对象）</td>
<td></td>
<td></td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>[]（任意数组）</td>
<td><strong>&quot;&quot;</strong></td>
<td><strong>0</strong></td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>[9]（1个数字对象）</td>
<td>&quot;9&quot;</td>
<td><strong>9</strong></td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>['a']（其他数组）</td>
<td>使用 join() 方法</td>
<td>NaN</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>function(){}（任意函数）</td>
<td></td>
<td>NaN</td>
<td>true</td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="是非真假值判断">是非（真假值）判断</span></h2>
<p>任意 JavaScript 的值都可以转换为布尔值。以下值会被转换为 <code>false</code> ：</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code></li>
<li><code>-0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code> // 空字符串</li>
</ul>
<p>所有其他值，包括所有对象（数组）都会被转换成 <code>true</code></p>
<h2><span id="相等比较">相等比较</span></h2>
<p>相等比较包含隐式转换逻辑，比较运算 <code>x==y</code>, 其中 <code>x</code> 和 <code>y</code> 是值，产生 <code>true</code> 或者 <code>false</code>。这样的比较按如下方式进行：</p>
<ol>
<li>
<p>若 <code>Type(x)</code> 与 <code>Type(y)</code> 相同， 则</p>
<ol>
<li>
<p>若 <code>Type(x)</code> 为 <code>Undefined</code>（同为 <code>Undefined</code>）， 返回 <code>true</code>。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>Null</code>（同为 <code>Null</code>）， 返回 <code>true</code>。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>Number</code>， 则</p>
<ol>
<li>若 <code>x</code> 为 <code>NaN</code>， 返回 <code>false</code>。</li>
<li>若 <code>y</code> 为 <code>NaN</code>， 返回 <code>false</code>。</li>
<li>若 <code>x</code> 与 <code>y</code> 为相等数值， 返回 <code>true</code>。</li>
<li>若 <code>x</code> 为 <code>+0</code> 且 <code>y</code> 为 <code>−0</code>， 返回 <code>true</code>。</li>
<li>若 <code>x</code> 为 <code>−0</code> 且 <code>y</code> 为 <code>+0</code>， 返回 <code>true</code>。</li>
<li>返回 <code>false</code>。</li>
</ol>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>String</code>, 则当 <code>x</code> 和 <code>y</code> 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 <code>true</code>。 否则， 返回 <code>false</code>。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>Boolean</code>, 当 <code>x</code> 和 <code>y</code> 为同为 <code>true</code> 或者同为 <code>false</code> 时返回 <code>true</code>。 否则， 返回 <code>false</code>。</p>
</li>
<li>
<p>当 <code>x</code> 和 <code>y</code> 为引用同一对象时返回 <code>true</code>。否则，返回 <code>false</code>。</p>
</li>
</ol>
</li>
<li>
<p>若 <code>x</code> 为 <code>null</code> 且 <code>y</code> 为 <code>undefined</code>， 返回 <code>true</code>。</p>
</li>
<li>
<p>若 <code>x</code> 为 <code>undefined</code> 且 <code>y</code> 为 <code>null</code>， 返回 <code>true</code>。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>Number</code> 且 <code>Type(y)</code> 为 <code>String</code>， 返回比较 <code>x == ToNumber(y)</code> 的结果。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>String</code> 且 <code>Type(y)</code> 为 <code>Number</code>，返回比较 <code>ToNumber(x) == y</code> 的结果。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>Boolean</code>， 返回比较 <code>ToNumber(x) == y</code> 的结果。</p>
</li>
<li>
<p>若 <code>Type(y)</code> 为 <code>Boolean</code>， 返回比较 <code>x == ToNumber(y)</code> 的结果。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 <code>String</code> 或 <code>Number</code>，且 <code>Type(y)</code> 为 <code>Object</code>，返回比较 <code>x == ToPrimitive(y)</code> 的结果。</p>
</li>
<li>
<p>若 <code>Type(x)</code> 为 Object 且 <code>Type(y)</code> 为 <code>String</code> 或 <code>Number</code>， 返回比较 <code>ToPrimitive(x) == y</code> 的结果。</p>
</li>
<li>
<p>返回 <code>false</code>。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[迟来的阶段大总结]]></title>
      <url>https://blog.tiy.xyz/posts/2018/1710259336/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>项目都是经历，不以项目为目的，对各种参与的项目进行抽象总结，回顾历史，铭记错误，增强抵抗力。</p>
<a id="more"></a>
<h2><span id="序曲">序曲</span></h2>
<p>时间过得太快，忙忙碌碌之后，让我不禁感叹，终于有心情闲下来，做一次全面的阶段总结。</p>
<p>项目都是经历，不以项目为目的，以下对各种参与的项目进行抽象总结，回顾历史，铭记错误，增强抵抗力。时间不分先后。</p>
<h2><span id="类型">类型</span></h2>
<p>按照项目类型，不区分移动端和PC端，如下：</p>
<ul>
<li>商城</li>
<li>微信小程序</li>
<li>智能终端-混合应用（Hybrid APP）</li>
<li>LED屏幕展示</li>
<li>快递打印面单</li>
<li>后台管理系统</li>
</ul>
<h2><span id="项目构建">项目构建</span></h2>
<p>按照项目建立和开发的流程，主要包含如下：</p>
<ul>
<li>框架 + grunt + less</li>
<li>框架 + gulp + babel + sass</li>
<li>框架 + webpack + sass</li>
<li>框架 + 插件 + gulp + 原生写法</li>
<li>gulp + babel + sass</li>
<li>webpack + sass</li>
</ul>
<h2><span id="框架库">框架/库</span></h2>
<p>项目中使用到的库/框架，主要有：</p>
<ul>
<li>jQuery</li>
<li><a href="//github.com/jquery/jquery-mobile">jQuery-Mobile</a></li>
<li><a href="//github.com/jquery/jquery-ui">jQuery-UI</a></li>
<li><a href="//www.bootcss.com/">Bootstrap</a></li>
<li><a href="//github.com/amazeui/amazeui">Amaze-UI</a></li>
<li><a href="//github.com/nolimits4web/Framework7">Framework7</a></li>
<li><a href="//github.com/Tencent/weui">WeUI</a></li>
<li><a href="//github.com/nuxt/nuxt.js">Nuxt</a></li>
<li><a href="//github.com/vuejs/vue">Vue</a></li>
<li><a href="//github.com/Tencent/wepy">WePy</a></li>
</ul>
<h2><span id="终章">终章</span></h2>
<p>综合归类之后，看起来就很清晰了。感觉做了很多事情，但又好像什么也没做。</p>
<p>工欲善其事必先利其器，项目中用到的工具很多，但更新换代也很快，伴随着一个个问题的解决，工具也会逐步被更新或替代。而语言也是一种工具。</p>
<p>项目经历，增强的不应只是对工具的熟练应用能力，而更多的是对解决问题需要用到的方法和工具的选择和掌控能力。</p>
<p>很常见的一种现象是，引入一个工具，同时埋藏了若干后来才会发现的问题；终于又不得不引入另一个工具来解决这个问题，环环相扣。</p>
<p>用工具解决问题并没错，关键在于，工具的选择以及使用方式是由我们决定的。我们需要解决的问题是，如何选择一个最合适的工具并以最干净的方式最快地解决问题。</p>
]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS禅意花园示范作]]></title>
      <url>https://blog.tiy.xyz/posts/2017/3721315630/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>CSS禅意花园初试，仅供学习，欢迎交流（文末有链接哦）</p>
<a id="more"></a>
<h2><span id="花语">花语</span></h2>
<p>传说有一位美丽端庄、冰清玉洁的女孩。因为她的温柔贤淑，村里的人都很喜欢她。有一年年初，气候寒冷，村庄遭受了严重的冰灾，春天迟迟不来，人们把过冬的粮食都吃光了。看着大家饿得倒下，冰凌花心急如焚，向上苍祈祷：“伟大的上苍，快让田野里长出也才吧。救救孩子们，救救老人们，救救大家吧!” 上苍听了非常感动。</p>
<p>一天晚上，女孩在梦里梦见了一位白胡子老爷爷对她说：“你能光着脚在冰雪里走遍山川田野吗？” “能”，冰凌花坚定的回答到。说完，老爷爷就递给了她一包种子。然后老爷爷就消失不见了。当她醒来的时候，发现自己的手里有一包种子。她光着脚跑向了田野，一边跑一边回头把种子撒在她的脚印里，脚底的鲜血滋润着种子，不一会就长出了小绿芽。接着就看见一朵朵黄色的小花从雪地里探出头来。</p>
<p>这些小花拯救了全村人的性命。</p>
<h2><span id="然之">然之</span></h2>
<p>众所周知，“CSS禅意花园”，无论是CSS从入门到精通（放弃？），还是深入浅出CSS系列，她都是令人难以忘怀的经典。</p>
<p>所以，近期带着滔滔江水之情，试手了这次初探之作。</p>
<h2><span id="附言">附言</span></h2>
<p>仅此一人？ No No No，佳人相伴才能有心望月。3年同窗，即是故交，亦是新知。 —— 致亲爱的大鹏</p>
<p>前期先大致实现视觉稿的还原，后期再进行适配和兼容调整等优化。So，目前需在现代较新浏览器下浏览才能达到最佳效果。</p>
<h2><span id="吐槽">吐槽</span></h2>
<ol>
<li>内容：同行的小伙伴都应该（需要）知道，CSS禅意花园的规则：<strong>同一份HTML代码</strong>，用<strong>不同的CSS样式</strong>创造天下。那么问题来了，由于小伙伴可能对于代码的不熟悉，偏向于UI的调整，忽视了实际代码无法改变的从上到下的顺序和文章内容结构，这带来了一些小麻烦：
<ul>
<li>比如截取两个独立section中的内容合并为第三者？</li>
<li>同一个section中的内容，一个放在右边自成一体，另一个放在左下边当作点缀，还好机智的我没有放弃治疗（英俊脸）</li>
<li>上下颠倒两个section的位置（内容高度不固定）</li>
</ul>
</li>
<li>字体：设计稿中有几种不同的字体，很不幸的在我的电脑上都不存在（相信大部分人也不存在，来咬我呀），在打开PSD的时候文字提示框点击“不要解决”我其实是拒绝的，得准备讨论一下（迷茫脸）</li>
<li>貌似定死的1080p宽屏稿让我有点忧伤</li>
<li>奇淫技巧当然还得过奇淫浏览器的关啦（深沉脸）</li>
</ol>
<h2><span id="重点">重点</span></h2>
<p>重点当然是链接啦，无图无真相（调皮脸）</p>
<p><a href="/showcase/csszengarden/001">CSS禅意花园初试</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript知识点]]></title>
      <url>https://blog.tiy.xyz/posts/2016/3711766572/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>JavaScript知识点</p>
<a id="more"></a>
<h2><span id="命名空间">命名空间</span></h2>
<blockquote>
<p>在JavaScript中，命名空间只是另一个包含方法、属性和对象的对象。</p>
</blockquote>
<h2><span id="变量">变量</span></h2>
<blockquote>
<p>JavaScript 中局部变量只可能通过两种方式声明，一个是作为函数参数，另一个是通过 var 关键字声明。</p>
</blockquote>
<p><code>undefined</code></p>
<blockquote>
<p>在 JavaScript 中 undefined 是一个<strong>变量</strong>，注意是变量不是关键字。
undefined 是一个值为 undefined 的类型。
这个语言也定义了一个全局变量，它的值是 undefined，这个变量也被称为 undefined。
但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。
由于全局变量 undefined 只是保存了 undefined 类型实际值的副本， 因此对它赋新值不会改变类型 undefined 的值。</p>
</blockquote>
<h2><span id="对象">对象</span></h2>
<blockquote>
<p>一个对象的属性名可以是任何有效的JavaScript字符串,或者可以被转换为字符串的任何东西，包括空字符串。然而，一个属性的名称如果不是一个有效的 JavaScript 标识符（例如，一个有空格或短横线，或者以数字开头的属性名），就只能通过方括号标记访问。这个标记法在属性名称是动态判定（属性名只有到运行时才能判定）时非常有用。例如：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    str   = <span class="string">"myString"</span>,</span><br><span class="line">    rand  = <span class="built_in">Math</span>.random(),</span><br><span class="line">    obj   = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">myObj.type              = <span class="string">"Dot syntax"</span>;</span><br><span class="line">myObj[<span class="string">"date created"</span>]   = <span class="string">"String with space"</span>;</span><br><span class="line">myObj[str]              = <span class="string">"String value"</span>;</span><br><span class="line">myObj[rand]             = <span class="string">"Random Number"</span>;</span><br><span class="line">myObj[obj]              = <span class="string">"Object"</span>;</span><br><span class="line">myObj[<span class="string">""</span>]               = <span class="string">"Even an empty string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果一个对象是通过在顶级脚本的对象初始化器创建的，则JavaScript在每次遇到包含该对象字面量的表达式时都会创建对象。同样的，在函数中的初始化器在每次函数调用时也会被创建。</p>
</blockquote>
<blockquote>
<p>所有的 JavaScript 对象继承于至少一个对象。被继承的对象被称作原型，并且继承的属性可能通过构造函数的 prototype 对象找到。</p>
</blockquote>
<h2><span id="原型链继承">原型链继承</span></h2>
<p>要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。
更进一步，绝对不要扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p>
<h2><span id="不要使用eval">不要使用Eval</span></h2>
<blockquote>
<p>eval 只在被直接调用并且调用函数就是 eval 本身时，才在当前作用域中执行。
也就是说，其他情况都是在全局作用域中执行。</p>
</blockquote>
<blockquote>
<p>在任何情况下我们都应该避免使用 eval 函数。99.9% 使用 eval 的场景都有不使用 eval 的解决方案。</p>
</blockquote>
<h2><span id="数据类型">数据类型</span></h2>
<h3><span id="字符串">字符串</span></h3>
<blockquote>
<p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与C语言不同，JavaScript中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。
JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。</p>
</blockquote>
<blockquote>
<p>除非必要, 应该尽量使用String字面值, 因为String对象的某些行为可能并不与直觉一致. 举例:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"2 + 2"</span>; <span class="comment">// Creates a string literal value</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"2 + 2"</span>); <span class="comment">// Creates a String object</span></span><br><span class="line"><span class="built_in">eval</span>(s1); <span class="comment">// Returns the number 4</span></span><br><span class="line"><span class="built_in">eval</span>(s2); <span class="comment">// Returns the string "2 + 2"</span></span><br></pre></td></tr></table></figure>
<h2><span id="数字和日期">数字和日期</span></h2>
<blockquote>
<p>在JavaScript里面，数字都是双精度浮点类型的（也就是说一个数字只能在 -(2^53 -1) 和 2^53 -1之间）。没有特定的数据类型为整型。</p>
</blockquote>
<h3><span id="十进制数字">十进制数字</span></h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="comment">// 数字第一个为零的注意事项：</span></span><br><span class="line"></span><br><span class="line"><span class="number">0888</span> <span class="comment">// 888 将被当做十进制处理</span></span><br><span class="line"><span class="number">0777</span> <span class="comment">// 在非严格格式下会被当做八进制处理 (用十进制表示就是511)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意，十进制可以以0开头，后面接其他十进制数字，但是假如后面接的十进制数字小于8，那么该数字将会被当做八进制处理。</span></span><br></pre></td></tr></table></figure>
<h3><span id="二进制数字">二进制数字</span></h3>
<blockquote>
<p>二进制数字语法是以零为开头，后面接一个小写或大写的拉丁文字母B(0b或者是0B)。  假如0b后面的数字不是0或者1，那么就会提示这样的语法错误（ SyntaxError）： &quot;Missing binary digits after 0b&quot;。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FLT_SIGNBIT  = <span class="number">0b10000000000000000000000000000000</span>; <span class="comment">// 2147483648</span></span><br></pre></td></tr></table></figure>
<h3><span id="八进制数字">八进制数字</span></h3>
<blockquote>
<p>八进制数字语法是以0为开头的。假如0后面的数字不在0到7的范围内，改数字将会被转换成十进制数字。</p>
</blockquote>
<h3><span id="十六进制数字">十六进制数字</span></h3>
<blockquote>
<p>十六进制数字语法是以零为开头，后面接一个小写或大写的拉丁文字母X(0x或者是0X)。</p>
</blockquote>
<h2><span id="数组">数组</span></h2>
<blockquote>
<p>如果在创建数组时给数组操作符的是一个非整形数值（如3.4），那么它将作为一个代表数组的对象的属性创建，而非作为数组的元素。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">3.4</span>] = <span class="string">"Oranges"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);                <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty(<span class="number">3.4</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组操作符（方括号）也可以用来访问数组的属性(在JavaScript中，数组也是对象)。例如：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>];</span><br><span class="line">arr[<span class="number">2</span>];  <span class="comment">// three</span></span><br><span class="line">arr[<span class="string">"length"</span>];  <span class="comment">// 3, equal to: arr.length</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组操作方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">push()    <span class="comment">// 在数组'末尾'添加一个或多个元素，并返回数组操作后的新长度。</span></span><br><span class="line">unshift() <span class="comment">// 在数组'开头'添加一个或多个元素，并返回数组的新长度。</span></span><br><span class="line">pop()     <span class="comment">// 从数组移出'最后一个'元素，并返回该元素。</span></span><br><span class="line">shift()   <span class="comment">// 从数组移出'第一个'元素，并返回该元素。</span></span><br><span class="line"></span><br><span class="line">slice(start_index, upto_index) <span class="comment">// 从数组提取一个片段，并作为一个新数组返回。</span></span><br><span class="line">splice(index, count_to_remove, addElement1, addElement2, ...) <span class="comment">// 从数组移出一些元素，（可选）并替换它们。</span></span><br><span class="line"></span><br><span class="line">reverse() <span class="comment">// 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。</span></span><br><span class="line">sort()    <span class="comment">// 给数组元素排序。</span></span><br><span class="line"></span><br><span class="line">indexOf(searchElement[, fromIndex])     <span class="comment">// 在数组中搜索searchElement 并返回第一个匹配的索引。</span></span><br><span class="line">lastIndexOf(searchElement[, fromIndex]) <span class="comment">// 和 indexOf差不多，但是是从结尾开始，并且是反向搜索。</span></span><br><span class="line"></span><br><span class="line">forEach(callback[, thisObject]) <span class="comment">// 在数组'每个元素'项上执行callback。</span></span><br><span class="line">map(callback[, thisObject])     <span class="comment">// 在数组的每个单元项上执行callback函数，并返回包含回调函数返回值的新数组。</span></span><br><span class="line">filter(callback[, thisObject])  <span class="comment">// 返回一个包含所有在回调函数上返回为true的元素的新数组。</span></span><br><span class="line"></span><br><span class="line">every(callback[, thisObject]) <span class="comment">// 当数组中'每一个元素'在callback上被返回true时就返回true。</span></span><br><span class="line">some(callback[, thisObject])  <span class="comment">// 数组中'只要有一项'在callback上被返回true，就返回true。</span></span><br></pre></td></tr></table></figure>
<h3><span id="理解数组的length">理解数组的length</span></h3>
<blockquote>
<p>在实施层面，JavaScript实际上是将元素作为标准的对象属性来存储，把数组索引作为属性名。长度属性是特殊的，它总是返回最后一个元素的索引值加1(下例中， Dusty 的索引是30，所以cats.length 返回 30 + 1)。  记住，JavaScript数组索引是基于0的:他们从0开始，而不是1。这意味着数组长度属性将比最大的索引值大1:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cats = [];</span><br><span class="line">cats[<span class="number">30</span>] = [<span class="string">'Dusty'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(cats.length); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你也可以分配length属性。写一个小于数组元素数量的值会缩短数组，写0会彻底清空数组：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cats = [<span class="string">'Dusty'</span>, <span class="string">'Misty'</span>, <span class="string">'Twiggy'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(cats.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">cats.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cats); <span class="comment">// logs "Dusty,Misty" - Twiggy has been removed</span></span><br><span class="line"></span><br><span class="line">cats.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cats); <span class="comment">// logs nothing; the cats array is empty</span></span><br><span class="line"></span><br><span class="line">cats.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cats); <span class="comment">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<h2><span id="遍历">遍历</span></h2>
<blockquote>
<p>for in 循环不会遍历那些 enumerable 设置为 false 的属性；比如数组的 length 属性。
for in 总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。</p>
</blockquote>
<blockquote>
<p>总结：为了更好的性能，推荐使用普通的 for 循环并缓存数组的 length 属性。
使用 for in 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>
</blockquote>
<h2><span id="settimeout-和-setinterval">setTimeout 和 setInterval</span></h2>
<blockquote>
<p>基于 JavaScript 引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞此线程。
因此没法确保函数会在 setTimeout 指定的时刻被调用。</p>
</blockquote>
<blockquote>
<p>作为第一个参数的函数将会在全局作用域中执行，因此函数内的 this 将会指向这个全局对象。</p>
</blockquote>
<blockquote>
<p>setTimeout 和 setInterval 也接受第一个参数为字符串的情况。
这个特性绝对不要使用，因为它在内部使用了 eval。</p>
</blockquote>
<h2><span id="参考">参考</span></h2>
<p><a href="//developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN</a>
<a href="//bonsaiden.github.io/JavaScript-Garden/zh">JavaScript 秘密花园</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript编码习惯和技巧]]></title>
      <url>https://blog.tiy.xyz/posts/2016/1104843291/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>JavaScript编码习惯和技巧</p>
<a id="more"></a>
<h2><span id="运用-和ampamp运算符">运用 || 和&amp;&amp;运算符</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">foo == <span class="number">10</span> &amp;&amp; doSomething(); <span class="comment">// is the same thing as if (foo == 10) doSomething();</span></span><br><span class="line">foo == <span class="number">5</span> || doSomething(); <span class="comment">// is the same thing as if (foo != 5) doSomething();</span></span><br></pre></td></tr></table></figure>
<h2><span id="运用-运算符">运用 | 运算符</span></h2>
<p>在js整数操作的时候，相当于去除小数点（取整），parseInt。在正数的时候相当于Math.floor()，负数的时候相当于Math.ceil()
<em>[<a href="//www.haorooms.com/post/js_dsg_ysf">REF</a>]</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil()  用作向上取整。</span><br><span class="line"><span class="built_in">Math</span>.floor() 用作向下取整。</span><br><span class="line"><span class="built_in">Math</span>.round() 我们数学中常用到的四舍五入取整。</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.6</span>|<span class="number">0</span>)<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.1</span>|<span class="number">0</span>)<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3.65555</span>|<span class="number">0</span>)<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5.99999</span>|<span class="number">0</span>)<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-7.777</span>|<span class="number">0</span>)<span class="comment">//-7</span></span><br></pre></td></tr></table></figure>
<p>同理有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n&lt;&lt;<span class="number">0</span></span><br><span class="line">n&gt;&gt;<span class="number">0</span></span><br><span class="line">~~n</span><br></pre></td></tr></table></figure>
<h2><span id="用map遍历处理数组">用map遍历处理数组</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> squares = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val * val;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// squares will be equal to [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>
<h2><span id="浮点数处理">浮点数处理</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2.443242342</span>;</span><br><span class="line">num = num.toFixed(<span class="number">4</span>);  <span class="comment">// num will be equal to 2.4432</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// is false, 0.30000000000000004 instead.</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> <span class="comment">// is equal to 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> <span class="comment">// is equal to 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//use toFixed() or toPrecision() to solve this problem</span></span><br><span class="line"><span class="comment">//NOTE : the toFixed() and toPrecision() function returns a string, not a number.</span></span><br></pre></td></tr></table></figure>
<h2><span id="用而不是">用'==='而不是'=='</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>] === <span class="number">10</span>    <span class="comment">// is false</span></span><br><span class="line">[<span class="number">10</span>] ==  <span class="number">10</span>    <span class="comment">// is true</span></span><br><span class="line"><span class="string">'10'</span> ==  <span class="number">10</span>    <span class="comment">// is true</span></span><br><span class="line"><span class="string">'10'</span> === <span class="number">10</span>    <span class="comment">// is false</span></span><br><span class="line"> []  ==  <span class="number">0</span>     <span class="comment">// is true</span></span><br><span class="line"> []  === <span class="number">0</span>     <span class="comment">// is false</span></span><br><span class="line"> <span class="string">''</span>  ==  <span class="literal">false</span> <span class="comment">// is true but true == "a" is false</span></span><br><span class="line"> <span class="string">''</span>  === <span class="literal">false</span> <span class="comment">// is false</span></span><br><span class="line"></span><br><span class="line"> <span class="string">""</span>        == <span class="string">"0"</span>       <span class="comment">// false</span></span><br><span class="line"> <span class="number">0</span>         == <span class="string">""</span>        <span class="comment">// true</span></span><br><span class="line"> <span class="number">0</span>         == <span class="string">"0"</span>       <span class="comment">// true</span></span><br><span class="line"> <span class="literal">false</span>     == <span class="string">"false"</span>   <span class="comment">// false</span></span><br><span class="line"> <span class="literal">false</span>     == <span class="string">"0"</span>       <span class="comment">// true</span></span><br><span class="line"> <span class="literal">false</span>     == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"> <span class="literal">false</span>     == <span class="literal">null</span>      <span class="comment">// false</span></span><br><span class="line"> <span class="literal">null</span>      == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"> <span class="string">" \t\r\n"</span> == <span class="number">0</span>         <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有趣的现象： &quot;&quot; == &quot;0&quot; 且 0 == &quot;0&quot;，但是 &quot;&quot; == 0 为false，当然这是js隐式转换的问题</p>
<h2><span id="布尔型转换">布尔型转换</span></h2>
<blockquote>
<p>通过使用 否 操作符两次，可以把一个值转换为布尔型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="string">'foo'</span>;   <span class="comment">// true</span></span><br><span class="line">!!<span class="string">''</span>;      <span class="comment">// false</span></span><br><span class="line">!!<span class="string">'0'</span>;     <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'1'</span>;     <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'-1'</span>     <span class="comment">// true</span></span><br><span class="line">!!&#123;&#125;;      <span class="comment">// true</span></span><br><span class="line">!!<span class="literal">true</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2><span id="用switch处理判断truefalse">用switch处理判断(true/false)</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategory</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> category = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">isNaN</span>(age):</span><br><span class="line">      category = <span class="string">"not an age"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> (age &gt;= <span class="number">50</span>):</span><br><span class="line">      category = <span class="string">"Old"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> (age &lt;= <span class="number">20</span>):</span><br><span class="line">      category = <span class="string">"Baby"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      category = <span class="string">"Young"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> category;</span><br><span class="line">&#125;</span><br><span class="line">getCategory(<span class="number">5</span>);  <span class="comment">// will return "Baby"</span></span><br></pre></td></tr></table></figure>
<h2><span id="尽量用原生表达式而不是函数调用">尽量用原生表达式而不是函数调用</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(a,b);</span><br><span class="line">A.push(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//below is better</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> min = a &lt; b ? a : b;</span><br><span class="line">A[A.length] = v;</span><br></pre></td></tr></table></figure>
<h2><span id="数组连接">数组连接</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">'parsnip'</span>, <span class="string">'potato'</span>];</span><br><span class="line"><span class="keyword">var</span> moreVegs = [<span class="string">'celery'</span>, <span class="string">'beetroot'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge the second array into the first one</span></span><br><span class="line"><span class="comment">// Equivalent to vegetables.push('celery', 'beetroot');</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(vegetables, moreVegs);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vegetables); <span class="comment">// ['parsnip', 'potato', 'celery', 'beetroot']</span></span><br></pre></td></tr></table></figure>
<h2><span id="将arguments转换为数组">将arguments转换为数组</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> argArray = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="判断是否为数组">判断是否为数组</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or use...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(obj); <span class="comment">// its a new Array method</span></span><br></pre></td></tr></table></figure>
<h2><span id="判断是否为数字">判断是否为数字</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(n)) &amp;&amp; <span class="built_in">isFinite</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="打散字符串为单个字符数组">打散字符串为单个字符（数组）</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="创建自调用函数">创建自调用函数</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// some private code that will be executed automatically</span></span><br><span class="line">&#125;)();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = a + b;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;)(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="随机获取数组中元素">随机获取数组中元素</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">12</span>, <span class="number">548</span> , <span class="string">'a'</span> , <span class="number">2</span> , <span class="number">5478</span> , <span class="string">'foo'</span> , <span class="number">8852</span>, , <span class="string">'Doe'</span> , <span class="number">2145</span> , <span class="number">119</span>];</span><br><span class="line"><span class="keyword">var</span> randomItem = items[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * items.length)];</span><br></pre></td></tr></table></figure>
<h2><span id="生成固定范围内的数组">生成固定范围内的数组</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbersArray = [], max = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">1</span>; numbersArray.push(i++) &lt; max;);  <span class="comment">// numbersArray = [1,2,3 ... 100]</span></span><br></pre></td></tr></table></figure>
<h2><span id="打乱数组顺序">打乱数组顺序</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> , <span class="number">228</span> , <span class="number">400</span> , <span class="number">122205</span>, <span class="number">-85411</span>];</span><br><span class="line">numbers = numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>&#125;);</span><br><span class="line"><span class="comment">/* the array numbers will be equal for example to [120, 5, 228, -215, 400, 458, -85411, 122205]  */</span></span><br></pre></td></tr></table></figure>
<h2><span id="取得数组中最大或最小值">取得数组中最大或最小值</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> , <span class="number">228</span> , <span class="number">400</span> , <span class="number">122205</span>, <span class="number">-85411</span>];</span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"><span class="keyword">var</span> minInNumbers = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, numbers);</span><br></pre></td></tr></table></figure>
<h2><span id="不要用delete删除数组中的元素">不要用delete删除数组中的元素</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">12</span>, <span class="number">548</span> ,<span class="string">'a'</span> , <span class="number">2</span> , <span class="number">5478</span> , <span class="string">'foo'</span> , <span class="number">8852</span>, , <span class="string">'Doe'</span> ,<span class="number">2154</span> , <span class="number">119</span> ];</span><br><span class="line">items.length; <span class="comment">// return 11</span></span><br><span class="line"><span class="keyword">delete</span> items[<span class="number">3</span>]; <span class="comment">// return true</span></span><br><span class="line">items.length; <span class="comment">// return 11</span></span><br><span class="line"><span class="comment">/* items will be equal to [12, 548, "a", undefined × 1, 5478, "foo", 8852, undefined × 1, "Doe", 2154, 119]   */</span></span><br><span class="line"><span class="comment">// below is better</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = [<span class="number">12</span>, <span class="number">548</span> ,<span class="string">'a'</span> , <span class="number">2</span> , <span class="number">5478</span> , <span class="string">'foo'</span> , <span class="number">8852</span>, , <span class="string">'Doe'</span> ,<span class="number">2154</span> , <span class="number">119</span> ];</span><br><span class="line">items.length; <span class="comment">// return 11</span></span><br><span class="line">items.splice(<span class="number">3</span>,<span class="number">1</span>) ;</span><br><span class="line">items.length; <span class="comment">// return 10</span></span><br><span class="line"><span class="comment">/* items will be equal to [12, 548, "a", 5478, "foo", 8852, undefined × 1, "Doe", 2154, 119]   */</span></span><br></pre></td></tr></table></figure>
<h2><span id="缩减数组">缩减数组</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">12</span> , <span class="number">222</span> , <span class="number">1000</span> , <span class="number">124</span> , <span class="number">98</span> , <span class="number">10</span> ];</span><br><span class="line">myArray.length = <span class="number">4</span>; <span class="comment">// myArray will be equal to [12 , 222 , 1000 , 124].</span></span><br><span class="line"><span class="comment">//The array length is not a read only property.</span></span><br></pre></td></tr></table></figure>
<h2><span id="去除字符串前后空白">去除字符串前后空白</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果浏览器本身不支持String对象的trim方法,那么运行下面的代码可以兼容这些环境.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.prototype.trim) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="注意区分布尔值truefalse-与-布尔对象的值truefalse">注意区分布尔值true/false 与 布尔对象的值true/false</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (b) <span class="comment">// this condition evaluates to true</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="闭包利用闭包模拟私有方法">[闭包]利用闭包模拟私有方法</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Counter1 = makeCounter();</span><br><span class="line"><span class="keyword">var</span> Counter2 = makeCounter();</span><br><span class="line">alert(Counter1.value()); <span class="comment">/* 提示 0 */</span></span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line">alert(Counter1.value()); <span class="comment">/* 提示 2 */</span></span><br><span class="line">Counter1.decrement();</span><br><span class="line">alert(Counter1.value()); <span class="comment">/* 提示 1 */</span></span><br><span class="line">alert(Counter2.value()); <span class="comment">/* 提示 0 */</span></span><br></pre></td></tr></table></figure>
<h2><span id="数组排序函数">数组排序函数</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="将数组所有项累加">将数组所有项累加</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// total == 6</span></span><br></pre></td></tr></table></figure>
<h2><span id="数组扁平化">数组扁平化</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2><span id="点击其他空白地方执行操作如关闭等">点击其他（空白）地方执行操作，如关闭等</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tarExts = [</span><br><span class="line">    $ele1,</span><br><span class="line">    $ele2</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = tarExts.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tarExts[i].is(e.target) || tarExts[i].has(e.target).length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//do something when click on others</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装后</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attachBlankTap</span>(<span class="params">targetsExcluded, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tarExts = targetsExcluded;</span><br><span class="line">  <span class="comment">// convert to jQuery object</span></span><br><span class="line">  <span class="keyword">if</span> ($.isArray(tarExts)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = tarExts.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> tarExts[i] || (<span class="string">'object'</span> === <span class="keyword">typeof</span> tarExts[i] &amp;&amp; !tarExts[i] <span class="keyword">instanceof</span> jQuery))</span><br><span class="line">        tarExts[i] = $(tarExts[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> tarExts || (<span class="string">'object'</span> === <span class="keyword">typeof</span> tarExts &amp;&amp; !tarExts <span class="keyword">instanceof</span> jQuery)) &#123;</span><br><span class="line">    tarExts = [ $(tarExts) ];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//add event</span></span><br><span class="line">  $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($.isArray(tarExts)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, m = tarExts.length; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tarExts[j].is(e.target) || tarExts[j].has(e.target).length !== <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do something when click on others</span></span><br><span class="line">    <span class="keyword">if</span> (callback &amp;&amp; <span class="string">'function'</span> === <span class="keyword">typeof</span> callback) callback();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="复制对象">复制对象</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy;</span><br><span class="line">  copy = <span class="keyword">this</span>.constructor == <span class="built_in">Object</span> ? <span class="keyword">new</span> <span class="keyword">this</span>.constructor() : <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="keyword">this</span>.valueOf());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(copy[key] != <span class="keyword">this</span>[key])&#123;</span><br><span class="line">      copy[key] = <span class="string">'object'</span> === <span class="keyword">this</span>[key] ? <span class="keyword">this</span>[key].clone() : <span class="keyword">this</span>[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="firefox下设置或获取scrolltop需特定写法">Firefox下设置或获取scrollTop需特定写法</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollXY</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x,y;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.body.scrollTop)&#123; <span class="comment">//非标准写法,chrome能识别</span></span><br><span class="line">    x = <span class="built_in">document</span>.body.scrollLeft;</span><br><span class="line">    y = <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//标准写法</span></span><br><span class="line">    x = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">    y = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>:x, <span class="attr">y</span>:y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery写法</span></span><br><span class="line">$(<span class="string">"html, body"</span>).scrollTop()</span><br></pre></td></tr></table></figure>
<h2><span id="时间">时间</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取时间数值</span></span><br><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br></pre></td></tr></table></figure>
<h2><span id="关闭打开窗口">关闭打开窗口</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browserName = navigator.appName;</span><br><span class="line"><span class="keyword">if</span> (browserName == <span class="string">"Netscape"</span>) &#123;</span><br><span class="line">  <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">'_self'</span>, <span class="string">''</span>);</span><br><span class="line">  <span class="built_in">window</span>.close();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (browserName == <span class="string">"Microsoft Internet Explorer"</span>) &#123;</span><br><span class="line">  <span class="built_in">window</span>.opener = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">'_top'</span>);</span><br><span class="line">  <span class="built_in">window</span>.top.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="sibling-elements">Sibling elements</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.siblings();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">[].filter.call(el.parentNode.children, <span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> child !== el;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="iframe-contents">Iframe Contents</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$iframe.contents();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">iframe.contentDocument;</span><br></pre></td></tr></table></figure>
<h2><span id="get-style">Get style</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.css(<span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Known bug, will return 'auto' if style value is 'auto'</span></span><br><span class="line"><span class="keyword">const</span> win = el.ownerDocument.defaultView;</span><br><span class="line"><span class="comment">// null means not return pseudo styles</span></span><br><span class="line">win.getComputedStyle(el, <span class="literal">null</span>).color;</span><br></pre></td></tr></table></figure>
<h2><span id="dom-remove">DOM - remove</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$el.remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native</span></span><br><span class="line">el.parentNode.removeChild(el);</span><br></pre></td></tr></table></figure>
<h2><span id="创建重复字符串">创建重复字符串</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> stringToRepeat = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">var</span> repeatStr = <span class="keyword">new</span> <span class="built_in">Array</span>(count + <span class="number">1</span>).join(stringToRepeat); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>
<h2><span id="amp-按位与">&amp; (按位与)</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个数是否为2的n次幂，可以将其与自身减一相与</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">4</span></span><br><span class="line">(number &amp; number <span class="number">-1</span>) === <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2><span id="按位异或">^ (按位异或)</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不用第三个变量，就可以交换两个变量的值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>,</span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">a = a ^ b; <span class="comment">// 7</span></span><br><span class="line">b = a ^ b; <span class="comment">// 4</span></span><br><span class="line">a = a ^ b; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2><span id="objectprototypetostring">Object.prototype.toString()</span></h2>
<p>在toString()方法被调用时,会执行下面的操作步骤:</p>
<blockquote>
<p>如果this的值为undefined,则返回&quot;[object Undefined]&quot;.
如果this的值为null,则返回&quot;[object Null]&quot;.
让O成为调用ToObject(this)的结果.
让class成为O的内部属性[[Class]]的值.
返回三个字符串&quot;[object &quot;, class, 以及 &quot;]&quot;连接后的新字符串.</p>
</blockquote>
<p>由于 JavaScript 中一切都是对象，任何都不例外，对所有值类型应用Object.prototype.toString.call()</p>
<p>方法结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>));          <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">'123'</span>));        <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>));    <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>));         <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;));           <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));           <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br></pre></td></tr></table></figure>
<p>所有类型都会得到不同的字符串，几乎完美。
在JavaScript中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过 <strong>Object.prototype.toString()</strong> 方法.</p>
<h2><span id="判断对象是否为空对象即不包含任何原始属性">判断对象是否为空对象，即不包含任何原始属性</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="显示网页所有元素轮廓">显示网页所有元素轮廓</span></h2>
<p>控制台中输入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123; a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>) &#125;)</span><br></pre></td></tr></table></figure>
<h2><span id="利用a标签自动解析url">利用a标签自动解析URL</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseURL</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  a.href = url;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    source: url,</span><br><span class="line">    protocol: a.protocol.replace(<span class="string">':'</span>, <span class="string">''</span>),</span><br><span class="line">    host: a.hostname,</span><br><span class="line">    port: a.port,</span><br><span class="line">    query: a.search,</span><br><span class="line">    params: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret                 = &#123;&#125;,</span><br><span class="line">          seg                 = a.search.replace(<span class="regexp">/^\?/</span>, <span class="string">''</span>).split(<span class="string">'&amp;'</span>),</span><br><span class="line">          len = seg.length, i = <span class="number">0</span>, s;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!seg[i]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = seg[i].split(<span class="string">'='</span>);</span><br><span class="line">        ret[s[<span class="number">0</span>]] = s[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;)(),</span><br><span class="line">    file: (a.pathname.match(<span class="regexp">/\/([^\/?#]+)$/i</span>) || [, <span class="string">''</span>])[<span class="number">1</span>],</span><br><span class="line">    hash: a.hash.replace(<span class="string">'#'</span>, <span class="string">''</span>),</span><br><span class="line">    path: a.pathname.replace(<span class="regexp">/^([^\/])/</span>, <span class="string">'/$1'</span>),</span><br><span class="line">    relative: (a.href.match(<span class="regexp">/tps?:\/\/[^\/]+(.+)/</span>) || [, <span class="string">''</span>])[<span class="number">1</span>],</span><br><span class="line">    segments: a.pathname.replace(<span class="regexp">/^\//</span>, <span class="string">''</span>).split(<span class="string">'/'</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考： <a href="//james.padolsey.com/javascript/parsing-urls-with-the-dom/">Parsing URLs with the DOM!</a></p>
<h2><span id="利用tostring方法生成随机字符串">利用toString()方法生成随机字符串</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRandomAlphaNum</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rdmString = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (; rdmString.length &lt; len; rdmString += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> rdmString.substr(<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="禁止别人以iframe加载你的页面">禁止别人以iframe加载你的页面</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.location != <span class="built_in">window</span>.parent.location) <span class="built_in">window</span>.parent.location = <span class="built_in">window</span>.location;</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2>
<p><a href="//modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/">45 useful javascript tips tricks and best practices</a>
<a href="//github.com/oneuijs/You-Dont-Need-jQuery">You Don't Need jQuery</a>
<a href="//bonsaiden.github.io/JavaScript-Garden/zh">JavaScript 秘密花园</a>
<a href="//segmentfault.com/a/1190000002753931">盘点JavaScript里好用的原生API ꒰･◡･๑꒱</a>
<a href="//segmentfault.com/a/1190000002911253">关于原生js的一些研究</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 代码段 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript代码注释规范与示例]]></title>
      <url>https://blog.tiy.xyz/posts/2016/1640409887/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>JavaScript代码注释规范与示例</p>
<a id="more"></a>
<h2><span id="文件注释">文件注释</span></h2>
<p>文件注释位于文件的最前面，应包括文件的以下信息：概要说明及版本（必须）项目地址（开源组件必须）版权声明（必须）开源协议（开源组件必须）版本号（必须）修改时间（必须），以ISO格式表示（可使用Sublime Text的InsertDate插件插入）文件注释必须全部以英文字符表示，并存在于文件的开发版本与生产版本中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * jRaiser 2 Javascript Library</span></span><br><span class="line"><span class="comment"> * waterfall - v1.0.0 (2013-03-15T14:55:51+0800)</span></span><br><span class="line"><span class="comment"> * http://jraiser.org/ | Released under MIT license</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * www.abc.com - v1.1 (2015-12-08 15:30:32 +0800)</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2014-2015 abc.com</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>如果文件内包含了一些开源组件，则必须在文件注释中进行说明。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * jRaiser 2 Javascript Library</span></span><br><span class="line"><span class="comment"> * sizzle - v1.9.1 (2013-03-15T10:07:24+0800)</span></span><br><span class="line"><span class="comment"> * http://jraiser.org/ | Released under MIT license</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Include sizzle (http://sizzlejs.com/)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2><span id="普通注释">普通注释</span></h2>
<p>普通注释是为了帮助开发者和阅读者更好地理解程序，不会出现在API文档中。其中，单行注释以“ // ”开头；多行注释以“ /* ”开头，以“ */ ”结束。普通注释的使用需遵循以下规定。</p>
<p>总是在单行注释符后留一个空格。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is comment</span></span><br></pre></td></tr></table></figure>
<p>总是在多行注释的结束符前留一个空格（使星号对齐）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>不要把注释写在多行注释的开始符、结束符所在行。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* start</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">end */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  here is line 1</span></span><br><span class="line"><span class="comment">  here is line 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>不要编写无意义的注释。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化value变量为0</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果某段代码有功能未实现，或者有待完善，必须添加“TODO”标记，“TODO”前后应留一个空格。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 未处理IE6-8的兼容性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setOpacity</span>(<span class="params">node, val</span>) </span>&#123;</span><br><span class="line">  node.style.opacity = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="文档注释jsdoc">文档注释(JSDoc)</span></h2>
<p>文档注释将会以预定格式出现在API文档中。它以“ /* ”开头，以“ */ ”结束，其间的每一行均以“ * ”开头（均与开始符的第一个“ * ”对齐），且注释内容与“ * ”间留一个空格。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * comment</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>文档注释必须包含一个或多个注释标签。</p>
<p>@module 声明模块，用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块说明</span></span><br><span class="line"><span class="comment"> * @module 模块名</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Core模块提供最基础、最核心的接口</span></span><br><span class="line"><span class="comment"> * @module Core</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>@class 声明类，用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明</span></span><br><span class="line"><span class="comment"> * @class 类名</span></span><br><span class="line"><span class="comment"> * @constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>@class必须搭配@constructor或@static使用，分别标记非静态类与静态类。@constructor可以标识一个函数是构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点集合类</span></span><br><span class="line"><span class="comment"> * @class NodeList</span></span><br><span class="line"><span class="comment"> * @constructor</span></span><br><span class="line"><span class="comment"> * @param &#123;ArrayLike&lt;Element&gt;&#125; nodes 初始化节点</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>@method 声明函数或类方法，用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法说明</span></span><br><span class="line"><span class="comment"> * @method 方法名</span></span><br><span class="line"><span class="comment"> * @for 所属类名</span></span><br><span class="line"><span class="comment"> * @param &#123;参数类型&#125; 参数名 参数说明</span></span><br><span class="line"><span class="comment"> * @return &#123;返回值类型&#125; 返回值说明</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>没有指定 @for 时，表示此函数为全局或模块顶层函数。当函数为静态函数时，必须添加@static；当函数有参数时，必须使用@param；当函数有返回值时，必须使用@return（多类返回值用@returns {*|Type} ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前集合中指定位置的元素</span></span><br><span class="line"><span class="comment"> * @method</span></span><br><span class="line"><span class="comment"> * @for NodeList</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; [i=0] 位置下标。如果为负数，则从集合的最后一个元素开始倒数</span></span><br><span class="line"><span class="comment"> * @return &#123;Element&#125; 指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>@param 声明函数参数，必须与@method搭配使用。</p>
<p>当参数出现以下情况时，使用对应的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[参数名]</span><br></pre></td></tr></table></figure>
<p>参数有默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[参数名=默认值]</span><br></pre></td></tr></table></figure>
<p>@property 声明类属性及说明，用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @property &#123;属性类型&#125; 属性名 属性描述</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2><span id="其他文档注释">其他文档注释</span></h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@author 指示代码的作者</span><br><span class="line">@deprecated 指示一个函数已经废弃，而且在将来的代码版本中将彻底删除。要避免使用这段代码</span><br><span class="line">@version 指定发布版本</span><br><span class="line">@alias 函数或变量的别名</span><br><span class="line">@throws @exception 描述函数可能抛出的异常的类型</span><br><span class="line">@description 代码提示时显示被描述变量或者函数的描述信息</span><br><span class="line">@private 指示一个类或函数是私有的。私有类和函数不会出现在HTML文档中，除非运行JSDoc时提供了 --private 命令行选项</span><br><span class="line">@example 提示代码示例</span><br><span class="line">@extends &#123;type&#125; 标识继承于某个类型</span><br><span class="line">@type &#123;Type[,Type,...]&#125; 定义某个变量的类型</span><br><span class="line">@ignore JsDoc忽略有这个标记的函数</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2>
<p>js/javascript代码注释规范与示例（原文链接失踪了）
<a href="https://code.google.com/p/jsdoc-toolkit/w/list" target="_blank" rel="noopener">jsdoc-toolkit</a>
<a href="http://usejsdoc.org/" target="_blank" rel="noopener">@use JSDoc</a>
<a href="http://ask.dcloud.net.cn/article/129" target="_blank" rel="noopener">JSDoc+规范</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 代码段 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS编码习惯和技巧]]></title>
      <url>https://blog.tiy.xyz/posts/2016/2680227017/</url>
      <content type="html"><![CDATA[<!-- 摘要 -->
<p>CSS编码习惯和技巧，常用CSS代码段</p>
<a id="more"></a>
<h2><span id="quotlobotomized-owlquot-选择器">&quot;Lobotomized Owl&quot; 选择器</span></h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* + * &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="纯css滑动切换效果">纯CSS滑动切换效果</span></h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.slider</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: $VALUE$</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.slider</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">1000px</span>; <span class="comment">/* has limits */</span></span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">3s</span> ease; <span class="comment">/* animate to max-height */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="使用属性选择器显示空文本链接">使用属性选择器显示空文本链接</span></h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http"]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;a href="http://www.bootstrap.com/"&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="为默认链接添加样式如通过cms系统添加的链接">为默认链接添加样式（如通过CMS系统添加的链接）</span></h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[class]</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#008000</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="使用-box-sizing-属性可以使用通配符通配符效率低是误区">使用 box-sizing 属性，可以使用通配符（通配符效率低是误区）</span></h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">:before</span>,</span><br><span class="line">*<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">       <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">            <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="//i.wanz.im/2012/01/03/performance_testing_about_css_universal_selector/">关于css通配符性能问题不完全测试</a></p>
<h2><span id="不要在选择器末尾使用-通用选择器">不要在选择器末尾使用 * 通用选择器。</span></h2>
<p>CSS 选择器匹配规则是从右往左，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod</span> <span class="selector-class">.foo</span> * &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="块级元素右对齐">块级元素右对齐</span></h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block-right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="让overflowauto页面滚动条出现时不跳动">让overflow:auto页面滚动条出现时不跳动</span></h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">1150px</span>) &#123; <span class="comment">/* for大屏幕 */</span></span><br><span class="line"><span class="selector-class">.wrap-outer</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(100vw - 100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="//www.zhangxinxu.com/wordpress/2015/01/css-page-scrollbar-toggle-center-no-jumping/">让overflow:auto页面滚动条出现时不跳动</a></p>
<h2><span id="参考">参考</span></h2>
<p><a href="//github.com/AllThingsSmitty/css-protips">CSS Protips</a>
<a href="//github.com/cssdream/css-creating">CSS 创作指南</a>
<a href="//shawphy.com/2010/11/css-universal-selector.html">CSS通用元素选择器的都市流言</a>
<a href="//i.wanz.im/2012/01/03/performance_testing_about_css_universal_selector/">关于css通配符性能问题不完全测试</a></p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 代码段 </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
