<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Roboto:300,300italic,400,400italic,700,700italicLobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/assets/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="JavaScript,ECMAScript6,ES2015"><link rel="alternate" href="/atom.xml" title="清晓轩" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico?v=5.1.0"><meta name="description" content="通过阅读阮一峰老师著作《ECMAScript 6 入门》，提取和总结的 ECMAScript6 语法关键点"><meta name="keywords" content="JavaScript,ECMAScript6,ES2015"><meta property="og:type" content="article"><meta property="og:title" content="ECMAScript6 语法关键点"><meta property="og:url" content="https://blog.tiy.xyz/posts/2018/3526440553/index.html"><meta property="og:site_name" content="清晓轩"><meta property="og:description" content="通过阅读阮一峰老师著作《ECMAScript 6 入门》，提取和总结的 ECMAScript6 语法关键点"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-07-27T16:08:56.748Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ECMAScript6 语法关键点"><meta name="twitter:description" content="通过阅读阮一峰老师著作《ECMAScript 6 入门》，提取和总结的 ECMAScript6 语法关键点"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://blog.tiy.xyz/posts/2018/3526440553/"><title>ECMAScript6 语法关键点 | 清晓轩</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?2a081db05f2fa4d1a09a7ebdb24e7a63";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">清晓轩</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">在平淡中发现乐趣，从规矩中探寻方圆。凡事以大气去面对，孤独是一种态度。</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="hidden-tablet" id="menu-avatar"><a href="/about/"><img class="site-author-image" itemprop="image" src="/assets/images/avatar.png" alt="晓月风尘"></a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://blog.tiy.xyz/posts/2018/3526440553/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="晓月风尘"><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="清晓轩"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">ECMAScript6 语法关键点</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T23:23:38+08:00">2018-07-27 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a class="cloud-tie-join-count" href="/posts/2018/3526440553/#comments" itemprop="discussionUrl"><span class="post-comments-count join-count" itemprop="commentCount"></span> </a></span><span id="/posts/2018/3526440553/" class="leancloud_visitors" data-flag-title="ECMAScript6 语法关键点"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span><div class="post-description">通过阅读阮一峰老师著作《ECMAScript 6 入门》，提取和总结的 ECMAScript6 语法关键点</div></div></header><div class="post-body" itemprop="articleBody"><p>通过阅读阮一峰老师著作《ECMAScript 6 入门》，提取和总结的 ECMAScript6 语法关键点</p><a id="more"></a><h2><span id="目录">目录</span></h2><ul><li><a href="#%E2%9C%8E-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">✎ 变量声明</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li></ul></li><li><a href="#%E2%9C%8E-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">✎ 变量的解构赋值</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E6%8A%80%E5%B7%A7">技巧</a></li></ul></li><li><a href="#%E2%9C%8E-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95">✎ 字符串的扩展</a></li><li><a href="#%E2%9C%8E-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95">✎ 正则表达式的扩展</a><ul><li><a href="#regexp-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">RegExp 构造函数</a></li><li><a href="#u-%E4%BF%AE%E9%A5%B0%E7%AC%A6">u 修饰符</a></li></ul></li><li><a href="#%E2%9C%8E-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95">✎ 数值的扩展</a><ul><li><a href="#numberisfinite-%E5%92%8C-numberisnan">Number.isFinite 和 Number.isNaN</a></li><li><a href="#numberparseint-%E5%92%8C-numberparsefloat">Number.parseInt 和 Number.parseFloat</a></li><li><a href="#numberisinteger">Number.isInteger</a></li><li><a href="#numberepsilon">Number.EPSILON</a></li><li><a href="#mathsign">Math.sign</a></li></ul></li><li><a href="#%E2%9C%8E-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95">✎ 函数的扩展</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">函数参数的默认值</a></li><li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84-length-%E5%B1%9E%E6%80%A7">函数的 <code>length</code> 属性</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">函数定义</a></li><li><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96">尾调用优化</a></li></ul></li><li><a href="#%E2%9C%8E-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95">✎ 数组的扩展</a><ul><li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8">扩展运算符的应用</a></li><li><a href="#arrayfrom">Array.from</a></li><li><a href="#arrayof">Array.of</a></li><li><a href="#copywithin">copyWithin()</a></li><li><a href="#find-%E5%92%8C-findindex">find() 和 findIndex()</a></li><li><a href="#fill">fill()</a></li><li><a href="#entries%E3%80%81keys-%E5%92%8C-values">entries()、keys() 和 values()</a></li><li><a href="#includes">includes()</a></li><li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D">数组的空位</a></li></ul></li><li><a href="#%E2%9C%8E-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95">✎ 对象的扩展</a><ul><li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F">属性名表达式</a></li><li><a href="#objectis">Object.is()</a></li><li><a href="#objectassign">Object.assign()</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86">属性的遍历</a></li><li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">对象的扩展运算符</a><ul><li><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li><li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">扩展运算符</a></li></ul></li></ul></li><li><a href="#%E2%9C%8E-symbol">✎ Symbol</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84-symbol">作为属性名的 <code>Symbol</code></a></li><li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86">属性名的遍历</a></li><li><a href="#symbolfor">Symbol.for()</a></li><li><a href="#symbolkeyfor">Symbol.keyFor()</a></li></ul></li><li><a href="#%E2%9C%8E-set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">✎ Set 和 Map 数据结构</a><ul><li><a href="#set">Set</a></li><li><a href="#weakset">WeakSet</a></li><li><a href="#map">Map</a></li><li><a href="#weakmap">WeakMap</a></li></ul></li><li><a href="#%E2%9C%8E-proxy">✎ Proxy</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#proxy-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">Proxy 实例的方法</a><ul><li><a href="#get">get()</a></li><li><a href="#this-%E9%97%AE%E9%A2%98"><code>this</code> 问题</a></li></ul></li></ul></li><li><a href="#%E2%9C%8E-reflect">✎ Reflect</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li></ul></li><li><a href="#%E2%9C%8E-promise-%E5%AF%B9%E8%B1%A1">✎ Promise 对象</a><ul><li><a href="#promise-%E7%9A%84%E5%90%AB%E4%B9%89">Promise 的含义</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li><li><a href="#promiseprototypethen">Promise.prototype.then()</a></li><li><a href="#promiserace">Promise.race()</a></li><li><a href="#promiseresolve">Promise.resolve()</a></li><li><a href="#promisereject">Promise.reject()</a></li><li><a href="#%E9%99%84%E5%8A%A0%E6%96%B9%E6%B3%95">附加方法</a><ul><li><a href="#done"><code>done()</code></a></li><li><a href="#finally"><code>finally()</code></a></li></ul></li></ul></li><li><a href="#%E2%9C%8E-iterator-%E5%92%8C-forof-%E5%BE%AA%E7%8E%AF">✎ Iterator 和 for...of 循环</a><ul><li><a href="#iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5">Iterator（遍历器）的概念</a></li><li><a href="#%E9%BB%98%E8%AE%A4-iterator-%E6%8E%A5%E5%8F%A3">默认 Iterator 接口</a></li><li><a href="#%E8%B0%83%E7%94%A8-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88">调用 <code>Iterator</code> 接口的场合</a></li><li><a href="#%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-return%EF%BC%8Cthrow">遍历器对象的 <code>return()</code>，<code>throw()</code></a></li><li><a href="#forof-%E5%BE%AA%E7%8E%AF"><code>for...of</code> 循环</a><ul><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li></ul></li></ul></li><li><a href="#%E2%9C%8E-generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95">✎ Generator 函数的语法</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F">yield 表达式</a></li><li><a href="#%E4%B8%8E-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB">与 Iterator 接口的关系</a></li><li><a href="#next-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0">next() 方法的参数</a></li><li><a href="#forof-%E5%BE%AA%E7%8E%AF">for...of 循环</a></li><li><a href="#generatorprototypethrow">Generator.prototype.throw()</a></li><li><a href="#generatorprototypereturn">Generator.prototype.return()</a></li><li><a href="#next%E3%80%81throw%E3%80%81return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">next()、throw()、return() 的共同点</a></li><li><a href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F">yield* 表达式</a></li></ul></li><li><a href="#%E2%9C%8E-generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">✎ Generator 函数的异步调用</a><ul><li><a href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95">传统方法</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li><li><a href="#%E5%8D%8F%E7%A8%8B">协程</a></li><li><a href="#thunk-%E5%87%BD%E6%95%B0">Thunk 函数</a></li><li><a href="#co-%E6%A8%A1%E5%9D%97">co 模块</a></li></ul></li><li><a href="#%E2%9C%8E-async-%E5%87%BD%E6%95%B0">✎ async 函数</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li><li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">使用注意点</a></li><li><a href="#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">async 函数的实现原理</a></li></ul></li><li><a href="#%E2%9C%8E-class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">✎ Class 的基本语法</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></li><li><a href="#constructor-%E6%96%B9%E6%B3%95">constructor 方法</a></li><li><a href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">不存在变量提升</a></li><li><a href="#class-%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Class 的静态方法</a></li><li><a href="#class-%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">Class 的静态属性和实例属性</a></li><li><a href="#newtarget-%E5%B1%9E%E6%80%A7">new.target 属性</a></li></ul></li><li><a href="#%E2%9C%8E-class-%E7%9A%84%E7%BB%A7%E6%89%BF">✎ Class 的继承</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li><li><a href="#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C-proto-%E5%B1%9E%E6%80%A7">类的 <code>prototype</code> 属性和 <code>__proto__</code> 属性</a></li><li><a href="#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">原生构造函数的继承</a></li></ul></li><li><a href="#%E2%9C%8E-decorator">✎ Decorator</a></li><li><a href="#%E2%9C%8E-module-%E7%9A%84%E8%AF%AD%E6%B3%95">✎ Module 的语法</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li><li><a href="#export-%E5%91%BD%E4%BB%A4">export 命令</a></li><li><a href="#import-%E5%91%BD%E4%BB%A4">import 命令</a></li><li><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD">模块的整体加载</a></li><li><a href="#export-default-%E5%91%BD%E4%BB%A4">export default 命令</a></li></ul></li><li><a href="#%E2%9C%8E-module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0">✎ Module 的加载实现</a><ul><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD">浏览器加载</a></li><li><a href="#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82">ES6 模块与 CommonJS 模块的差异</a><ul><li><a href="#%E5%AF%B9%E6%AF%94">对比</a></li><li><a href="#commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86">CommonJS 模块的加载原理</a></li></ul></li><li><a href="#node-%E5%8A%A0%E8%BD%BD">Node 加载</a><ul><li><a href="#%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F">内部变量</a></li><li><a href="#es6-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD-commonjs-%E6%A8%A1%E5%9D%97">ES6 模块加载 CommonJS 模块</a></li><li><a href="#commonjs-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD-es6-%E6%A8%A1%E5%9D%97">CommonJS 模块加载 ES6 模块</a></li></ul></li><li><a href="#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">循环加载</a><ul><li><a href="#commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">CommonJS 模块的循环加载</a></li><li><a href="#es6-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">ES6 模块的循环加载</a></li></ul></li></ul></li><li><a href="#%E2%9C%8E-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC">✎ 编程风格</a></li><li><a href="#%E2%9C%8E-%E8%AF%BB%E6%87%82%E8%A7%84%E6%A0%BC">✎ 读懂规格</a></li><li><a href="#%E2%9C%8E-arraybuffer">✎ ArrayBuffer</a></li><li><a href="#%E2%9C%8E-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">✎ 参考链接</a></li></ul><h2><span id="变量声明">✎ 变量声明</span></h2><h3><span id="概述">概述</span></h3><ul><li><p>代码块，双大括号，拥有块级作用域</p></li><li><p>可不将大括号写在行首，取消 JavaScript 将其解释为代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考：变量的解构赋值（对象）</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>let</code> 声明的变量只在它所在的代码块有效</p></li><li><p><code>for</code> 循环中用 <code>let</code> 声明的 <code>i</code> 只在循环体内有效，且为父作用域内，与函数体作用域独立</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure></li><li><p><code>let</code> 不存在变量申明提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>TDZ（Temporal Dead Zone），暂时性死区</p><blockquote><p>只要块级作用域内存在 <code>let</code> 命令，它所声明的变量就 “绑定”（binding）这个区域，不再受外部的影响。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError: tmp is not defined</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“暂时性死区” 也意味着 <code>typeof</code> 不再是一个百分之百安全的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure></li><li><p>不允许重复声明</p></li><li><p><code>const</code> 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</p></li><li><p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>let</code>、<code>const</code> 和 <code>class</code> 命令声明的全局变量，不属于顶层对象（如 <code>window</code>）的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="变量的解构赋值">✎ 变量的解构赋值</span></h2><h3><span id="概述">概述</span></h3><ul><li><p>默认值：解构赋值指定默认值时，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于 <code>undefined</code>，默认值是不会生效的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li><li><p>函数的参数也可以使用解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="技巧">技巧</span></h3><ul><li><p>交换变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li><li><p>遍历 <code>Map</code> 结构</p><blockquote><p>任何部署了 <code>Iterator</code> 接口的对象，都可以用 <code>for...of</code> 循环遍历。<code>Map</code> 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只想获取键名，或者只想获取键值，可以写成下面这样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="字符串的扩展">✎ 字符串的扩展</span></h2><ul><li><p><code>codePointAt</code> 方法会正确返回<code>32位</code>的 <code>UTF-16</code> 字符的码点（10进制）。对于那些两个字节储存的常规字符，它的返回结果与 <code>charCodeAt</code> 方法相同</p></li><li><p>使用 <code>for...of</code> 循环，因为它会正确识别<code>32位</code>的<code>UTF-16</code>字符（可以识别大于 <code>0xFFFF</code> 的码点）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure></li><li><p><code>codePointAt</code> 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>); <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="正则表达式的扩展">✎ 正则表达式的扩展</span></h2><h3><span id="regexp-构造函数">RegExp 构造函数</span></h3><blockquote><p>如果 <code>RegExp</code> 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。 而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</span><br><span class="line"><span class="comment">// "i"</span></span><br></pre></td></tr></table></figure><h3><span id="u-修饰符">u 修饰符</span></h3><ul><li><p>ES6 对正则表达式添加了 <code>u</code> 修饰符，含义为 “<code>Unicode</code> 模式”，用来正确处理大于 <code>\uFFFF</code> 的 <code>Unicode</code> 字符。也就是说，会正确处理 4个字节 的 <code>UTF-16</code> 编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>); <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>一旦加上u修饰符号，就会修改下面这些正则表达式的行为</p><ul><li><p>点字符</p><blockquote><p>对于码点大于<code>0xFFFF</code>的 <code>Unicode</code> 字符，点字符不能识别，必须加上 <code>u</code> 修饰符</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line">/^.$/.test(s); <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Unicode</code> 字符表示法</p><blockquote><p>ES6 新增了使用大括号表示 <code>Unicode</code> 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>); <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>); <span class="comment">// true</span></span><br><span class="line">/\u&#123;<span class="number">20</span>BB7&#125;/u.test(<span class="string">'𠮷'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2><span id="数值的扩展">✎ 数值的扩展</span></h2><h3><span id="numberisfinite-和-numberisnan">Number.isFinite 和 Number.isNaN</span></h3><blockquote><p>它们与传统的全局方法 <code>isFinite()</code> 和 <code>isNaN()</code> 的区别在于，传统方法先调用 <code>Number()</code> 将非数值的值转为数值，再进行判断， 而这两个新方法只对数值有效，<code>Number.isFinite()</code> 对于非数值一律返回 <code>false</code>，而 <code>Number.isNaN()</code> 只有对于 <code>NaN</code> 才返回 <code>true</code>，<code>非NaN</code> 一律返回 <code>false</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; global_isFinite(value);</span><br></pre></td></tr></table></figure><h3><span id="numberparseint-和-numberparsefloat">Number.parseInt 和 Number.parseFloat</span></h3><p>从 <code>window</code> 对象上移植到 <code>Number</code> 对象上，行为不变</p><h3><span id="numberisinteger">Number.isInteger</span></h3><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">"15"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3><span id="numberepsilon">Number.EPSILON</span></h3><ul><li>ES6 在<code>Number</code>对象上面，新增一个极小的常量 <code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</li><li><code>Number.EPSILON</code> 实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了</li></ul><h3><span id="mathsign">Math.sign</span></h3><p><code>Math.sign</code> 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p><p>它会返回五种值：</p><ul><li>参数为正数，返回 <code>+1</code>；</li><li>参数为负数，返回 <code>-1</code>；</li><li>参数为 0，返 回<code>0</code>；</li><li>参数为-0，返回 <code>-0</code>;</li><li>其他值，返回 <code>NaN</code>。</li></ul><h2><span id="函数的扩展">✎ 函数的扩展</span></h2><h3><span id="函数参数的默认值">函数参数的默认值</span></h3><blockquote><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo(); <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><h3><span id="函数的-length-属性">函数的 <code>length</code> 属性</span></h3><blockquote><p><code>length</code> 属性的含义是，该函数<strong>预期传入</strong>的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了 指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code> 属性将失真。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length; <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length; <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length; <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length; <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length; <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3><span id="函数定义">函数定义</span></h3><blockquote><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure><h3><span id="尾调用优化">尾调用优化</span></h3><blockquote><p>定义：某个函数的最后一步是调用另一个函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的最后一步是调用函数 g，这就叫尾调用</p><p>以下三种情况，都<strong>不属于</strong>尾调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了 “尾调用优化” 对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。 ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署 “尾调用优化”。 这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存</p></blockquote><h2><span id="数组的扩展">✎ 数组的扩展</span></h2><h3><span id="扩展运算符的应用">扩展运算符的应用</span></h3><blockquote><p>扩展运算符有一个重要的好处，那就是能够正确识别 <strong>4</strong>个字节 的 <code>Unicode 字符</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length; <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript会将 4个字节 的 <code>Unicode</code> 字符，识别为 <strong>2</strong> 个字符，采用扩展运算符就没有这个问题。 因此，正确返回字符串长度的函数，可以像下面这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>凡是涉及到操作4个字节的 <code>Unicode</code> 字符的函数，都有这个问题。因此，最好都用扩展运算符改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>);</span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的 <code>reverse</code> 操作就不正确</p><h3><span id="arrayfrom">Array.from</span></h3><blockquote><p><code>Array.from()</code> 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 <code>Unicode</code> 字符，可以避免JavaScript将<strong>大于</strong> <code>\uFFFF</code> 的<code>Unicode</code>字符，算作两个字符的bug。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="arrayof">Array.of</span></h3><blockquote><p><code>Array.of</code> 方法用于将一组值，转换为数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3><span id="copywithin">copyWithin()</span></h3><blockquote><p>组实例的 <code>copyWithin</code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。 也就是说，使用这个方法，会修改当前数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3><span id="find-和-findindex">find() 和 findIndex()</span></h3><ul><li><p>数组实例的 <code>find</code> 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 <code>true</code> 的成员，然后返回该成员。如果没有符合条件的成员，则返回 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>find</code> 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p></li><li><p>数组实例的 <code>findIndex</code> 方法的用法与 <code>find</code> 方法非常类似，返回第一个符合条件的数组成员的<strong>位置</strong>，如果所有成员都不符合条件，则返回 <code>-1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="fill">fill()</span></h3><blockquote><p><code>fill</code> 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><h3><span id="entries-keys-和-values">entries()、keys() 和 values()</span></h3><blockquote><p>用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 <code>for...of</code> 循环进行遍历，唯一的区别是：</p></blockquote><ul><li><code>keys()</code> 是对键名的遍历</li><li><code>values()</code>是对键值的遍历</li><li><code>entries()</code>是对键值对的遍历</li></ul><h3><span id="includes">includes()</span></h3><blockquote><p><code>Array.prototype.includes</code> 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 <code>includes</code> 方法类似。ES2016 引入了该方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3><span id="数组的空位">数组的空位</span></h3><ul><li><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code> 构造函数返回的数组都是空位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p><p>注意，空位不是 <code>undefined</code>，一个位置的值等于 <code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code> 运算符可以说明这一点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ES5</strong> 对空位的处理，已经很不一致了，大多数情况下会忽略空位：</p><ul><li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和 <code>some()</code> 都会跳过空位</li><li><code>map()</code> 会跳过空位，但会保留这个值</li><li><code>join()</code> 和 <code>toString()</code> 会将空位视为 <code>undefined</code>，而 <code>undefined</code> 和 <code>null</code> 会被处理成空字符串</li></ul></li><li><p><strong>ES6</strong> 则是明确将空位转为 <code>undefined</code> ：</p><ul><li><p><code>Array.from</code>、扩展运算符（<code>...</code>） 方法会将数组的空位，转为 <code>undefined</code>，也就是说，这个方法不会忽略空位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>]);</span><br><span class="line"><span class="comment">// [ "a", undefined, "b" ]</span></span><br></pre></td></tr></table></figure></li><li><p><code>fill()</code> 会将空位视为正常的数组位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br></pre></td></tr></table></figure></li><li><p><code>copyWithin()</code> 会连空位一起拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...of</code> 循环也会遍历空位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code> 和 <code>findIndex()</code> 会将空位处理成 <code>undefined</code></p></li></ul></li><li><p><strong>由于空位的处理规则非常不统一，所以建议避免出现空位</strong></p></li></ul><h2><span id="对象的扩展">✎ 对象的扩展</span></h2><h3><span id="属性名表达式">属性名表达式</span></h3><p>可用 <strong>表达式</strong> 作为对象的属性名，即把表达式放在方括号内：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>表达式还可以用于定义方法名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><h3><span id="objectis">Object.is()</span></h3><blockquote><p>“Same-value equality”，同值相等，<code>Object.is</code> 就是部署这个算法的新方法。 它用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。不同之处只有两个：</p></blockquote><ul><li><code>+0</code> 不等于 <code>-0</code></li><li><code>NaN</code> 等于自身</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3><span id="objectassign">Object.assign()</span></h3><ul><li><p><code>Object.assign</code> 方法用于对象的合并，将源对象（<code>source</code>）的所有可枚举属性，复制到目标对象（<code>target</code>）如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果只有一个参数，<code>Object.assign</code> 会直接返回该参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>); <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></li><li><p>数值、字符串和布尔值不在首参数，不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。因为只有字符串的包装对象，会产生可枚举属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ol><li><p><code>Object.assign</code> 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>同名属性的替换</p><p>对于嵌套的对象，一旦遇到同名属性，<code>Object.assign</code> 的处理方法是替换，而不是添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>数组的处理</p><p><code>Object.assign</code> 可以用来处理数组，但是会把数组视为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">Object</span>.assign(arr1, [<span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">arr1 <span class="comment">// [4, 5, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>取值函数的处理</p><p><code>Object.assign</code> 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  get foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code> 对象的 <code>foo</code> 属性是一个取值函数，<code>Object.assign</code> 不会复制这个取值函数，只会拿到值以后，将这个值复制过去</p></li></ol><h3><span id="属性的遍历">属性的遍历</span></h3><p>属性遍历的次序规则：</p><ol><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有 <code>Symbol</code> 键，按照加入时间升序排列</li></ol><h3><span id="super-关键字">super 关键字</span></h3><p>指向当前对象的<strong>原型对象</strong></p><blockquote><p><code>super</code> 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="对象的扩展运算符">对象的扩展运算符</span></h3><h4><span id="解构赋值">解构赋值</span></h4><blockquote><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。 所有的键和它们的值，都会拷贝到新对象上面。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">o3.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4><span id="扩展运算符">扩展运算符</span></h4><blockquote><p>扩展运算符（<code>...</code>）用于取出参数对象的所有<strong>可遍历</strong>属性，拷贝到当前对象之中。</p></blockquote><p>扩展运算符可以用于合并两个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>扩展运算符的参数对象之中，如果有取值函数 <code>get</code>，这个函数是会执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  get x() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not throw yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为 x 属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    get x() &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="symbol">✎ Symbol</span></h2><h3><span id="概述">概述</span></h3><ul><li><p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：</p><ul><li><code>undefined</code></li><li><code>null</code></li><li>布尔值（<code>Boolean</code>）</li><li>字符串（<code>String</code>）</li><li>数值（<code>Number</code>）</li><li>对象（<code>Object</code>）</li></ul></li><li><p><code>Symbol</code> 函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的 <code>Symbol</code> 函数的返回值是不相等的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 值不能与其他类型的值进行运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"your symbol is "</span> + sym;</span><br><span class="line"><span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol</code> 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString(); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym2); <span class="comment">// true</span></span><br><span class="line">!sym2  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym2) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym2); <span class="comment">// TypeError</span></span><br><span class="line">sym2 + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="作为属性名的-symbol">作为属性名的 <code>Symbol</code></span></h3><blockquote><p><code>Symbol</code> 值作为对象属性名时，不能用点运算符，该属性还是公开属性，不是私有属性</p></blockquote><h3><span id="属性名的遍历">属性名的遍历</span></h3><blockquote><p><code>Symbol</code> 作为属性名，该属性不会出现在 <code>for...in</code>、<code>for...of</code> 循环中， 也不会被 <code>Object.keys()</code> 、<code>Object.getOwnPropertyNames()</code> 、 <code>JSON.stringify()</code> 返回。 但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名</p></blockquote><p><code>Reflect.ownKeys()</code> 方法可以返回所有类型的键名，包括常规键名和 <code>Symbol</code> 键名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure><h3><span id="symbolfor">Symbol.for()</span></h3><blockquote><p><code>Symbol.for</code> 方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。 如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Symbol.for()</code> 与 <code>Symbol()</code> 这两种写法，都会生成新的 <code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 <code>Symbol.for()</code> 不会每次调用就返回一个新的 <code>Symbol</code> 类型的值，而是会先检查给定的 <code>key</code> 是否已经存在，如果不存在才会新建一个值。 比如，如果你调用 <code>Symbol.for(&quot;cat&quot;)</code> 30 次，每次都会返回同一个 <code>Symbol</code> 值， 但是调用 <code>Symbol(&quot;cat&quot;)</code> 30 次，会返回 30 个不同的 <code>Symbol</code> 值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3><span id="symbolkeyfor">Symbol.keyFor()</span></h3><blockquote><p><code>Symbol.keyFor</code> 方法返回一个已登记的 <code>Symbol</code> 类型值的 <code>key</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>s2</code> 属于未登记的 <code>Symbol</code> 值，所以返回 <code>undefined</code></p><p>需要注意的是，<code>Symbol.for</code> 为 <code>Symbol</code> 值登记的名字，是全局环境的，可以在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>iframe</code> 窗口生成的 <code>Symbol</code> 值，可以在主页面得到</p><h2><span id="set-和-map-数据结构">✎ Set 和 Map 数据结构</span></h2><h3><span id="set">Set</span></h3><blockquote><p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值</p></blockquote><h3><span id="weakset">WeakSet</span></h3><ul><li><p><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与 <code>Set</code> 有两个区别：</p><ul><li><p>首先，<code>WeakSet</code> 的成员只能是<strong>对象</strong>，而不能是其他类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>上面代码试图向 <code>WeakSet</code> 添加一个数值和 <code>Symbol</code> 值，结果报错，因为 <code>WeakSet</code> 只能放置对象。</p></li><li><p>其次，<code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用。 也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中</p><blockquote><p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。 WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。 因此，<code>WeakSet</code> 适合临时存放一组对象，以及存放跟对象绑定的信息。 只要这些对象在外部消失，它在 <code>WeakSet</code> 里面的引用就会自动消失 由于上面这个特点，<code>WeakSet</code> 的成员是不适合引用的，因为它会随时消失。 另外，由于 <code>WeakSet</code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的， 而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet</code> 不可遍历</p></blockquote></li></ul></li><li><p><code>WeakSet</code> 可以接受一个数组或类似数组的对象作为参数（实际上，任何具有 <code>Iterable</code> 接口的对象，都可以作为 <code>WeakSet</code> 的参数）。该数组的所有成员（必须都为<strong>对象</strong>），都会自动成为 <code>WeakSet</code> 实例对象的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>WeakSet</code> 的一个用处，是储存 <code>DOM</code> 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</p></li></ul><h3><span id="map">Map</span></h3><blockquote><p><code>ES6</code> 提供了 <code>Map</code> 数据结构。它类似于对象，也是键值对的集合，但是 “键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 也就是说，<code>Object</code> 结构提供了 “字符串 — 值” 的对应，<code>Map</code> 结构提供了 “值 — 值” 的对应，是一种更完善的 <code>Hash</code> 结构实现。 如果你需要 “键值对” 的数据结构，<code>Map</code> 比 <code>Object</code> 更合适</p></blockquote><p>作为构造函数，<code>Map</code> 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>); <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>); <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure><h3><span id="weakmap">WeakMap</span></h3><blockquote><p><code>WeakMap</code> 的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code> 结构有助于防止内存泄漏</p></blockquote><p><code>WeakMap</code> 与 <code>Map</code> 的区别：</p><ol><li><p><code>WeakMap</code> 只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure></li><li><p><code>WeakMap</code> 的键名所指向的对象，不计入垃圾回收机制</p><blockquote><p><code>WeakMap</code> 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。 <code>WeakMap</code> 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。 因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。 也就是说，一旦不再需要，<code>WeakMap</code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(el, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(el) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure></li><li><p><code>WeakMap</code> 与 <code>Map</code> 在 API 上的区别主要是两个：</p><ul><li>没有遍历操作（即没有 <code>key()</code>、 <code>values()</code> 和 <code>entries()</code> 方法），也没有 <code>size</code> 属性</li><li>无法清空，即不支持clear方法</li></ul></li></ol><h2><span id="proxy">✎ Proxy</span></h2><h3><span id="概述">概述</span></h3><ul><li><p><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种 “元编程”（meta programming），即对编程语言进行编程。 <code>Proxy</code> 可以理解成，在目标对象之前架设一层 “拦截”，外界对该对象的访问，都必须先通过这层拦截， 因此提供了一种机制，可以对外界的访问进行过滤和改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure></li><li><p>如果 <code>handler</code> 没有设置任何拦截，那就等同于直接通向原对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="proxy-实例的方法">Proxy 实例的方法</span></h3><h4><span id="get">get()</span></h4><blockquote><p>如果一个属性不可配置（<code>configurable</code>）和不可写（<code>writable</code>），则该属性不能被代理，通过 <code>Proxy</code> 对象访问该属性会报错</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo <span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure><h4><span id="this-问题"><code>this</code> 问题</span></h4><blockquote><p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。 主要原因就是在 <code>Proxy</code> 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 <code>Proxy</code> 代理</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m(); <span class="comment">// false</span></span><br><span class="line">proxy.m();  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2><span id="reflect">✎ Reflect</span></h2><h3><span id="概述">概述</span></h3><ul><li><p><code>Reflect</code> 对象与 <code>Proxy</code> 对象一样，也是 <code>ES6</code> 为了操作对象而提供的新 API</p></li><li><p><code>Reflect</code> 对象的设计目的有这样几个：</p><ul><li><p>将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code>），放到 <code>Reflect</code> 对象上。 现阶段，某些方法同时在 <code>Object</code> 和 <code>Reflect</code> 对象上部署，未来的新方法将只部署在 <code>Reflect</code> 对象上。 也就是说，从 <code>Reflect</code> 对象上可以拿到语言内部的方法</p></li><li><p>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。 比如，<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一个错误， 而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让 <code>Object</code> 操作都变成函数行为。某些 <code>Object</code> 操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code> ， 而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> success = <span class="built_in">Reflect</span>.set(target,name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2><span id="promise-对象">✎ Promise 对象</span></h2><h3><span id="promise-的含义">Promise 的含义</span></h3><ul><li><p>所谓 <code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 <code>API</code>，各种异步操作都可以用同样的方法进行处理</p></li><li><p><strong>特点</strong>：</p><ul><li><p>对象的状态不受外界影响</p><blockquote><p><code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p></blockquote></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p><blockquote><p><code>Promise</code> 对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code>。</p></blockquote></li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>无法取消 <code>Promise</code>，一旦新建它就会立即执行，无法中途取消</li><li>如果不设置回调函数，<code>Promise</code> 内部抛出的错误，不会反应到外部</li><li>当处于 <code>pending</code> 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li></ul></li></ul><h3><span id="基本用法">基本用法</span></h3><ul><li><p>如果调用 <code>resolve</code> 函数和 <code>reject</code> 函数时带有参数，那么它们的参数会被传递给回调函数。 （如果参数是 <code>Promise</code> 的实例，那么参数的状态就会传递给改 <code>Promise</code> 的状态，即参数实例的状态决定了改实例的状态）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure></li><li><p>调用 <code>resolve</code> 或 <code>reject</code> 并不会终结 <code>Promise</code> 的参数函数的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>说明：立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</p></li></ul><h3><span id="promiseprototypethen">Promise.prototype.then()</span></h3><blockquote><p>采用链式的 <code>then</code>，可以指定一组按照次序调用的回调函数。 这时，前一个回调函数，有可能返回的还是一个 <code>Promise</code> 对象（即有异步操作）， 这时后一个回调函数，就会等待该 <code>Promise</code> 对象的状态发生变化，才会被调用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>)</span><br><span class="line">  .then(</span><br><span class="line">    post =&gt; getJSON(post.commentURL)</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.warn(<span class="string">"rejected: "</span>, err)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3><span id="promiserace">Promise.race()</span></h3><blockquote><p><code>Promise.race</code> 方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。 那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 p 的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内 <code>fetch</code> 方法无法返回结果，变量 <code>p</code> 的状态就会变为 <code>rejected</code>，从而触发 <code>catch</code> 方法指定的回调函数</p><h3><span id="promiseresolve">Promise.resolve()</span></h3><blockquote><p>将现有对象转为 <code>Promise</code> 对象</p></blockquote><p><code>Promise.resolve</code> 方法的参数分成四种情况：</p><ol><li><p>参数是一个 <code>Promise</code> 实例</p><blockquote><p>如果参数是 <code>Promise</code> 实例，那么 <code>Promise.resolve</code> 将不做任何修改、原封不动地返回这个实例</p></blockquote></li><li><p>参数是一个 <code>thenable</code> 对象</p><blockquote><p><code>thenable</code> 对象指的是具有 <code>then</code> 方法的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">   then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     resolve(<span class="number">42</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code> 方法会将这个对象转为 <code>Promise</code> 对象，然后就立即执行 <code>thenable</code> 对象的 <code>then</code> 方法</p></li><li><p>参数不是具有 <code>then</code> 方法的对象，或根本就不是对象</p><blockquote><p>如果参数是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，则 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为 <code>resolved</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li><li><p>不带有任何参数</p><blockquote><p><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个 <code>resolved</code> 状态的 <code>Promise</code> 对象</p></blockquote><p>注意：立即 <code>resolve</code> 的 <code>Promise</code> 对象，是在本轮 “事件循环”（<code>event loop</code>）的结束时，而不是在下一轮 “事件循环” 的开始时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中， <code>setTimeout(fn, 0)</code> 在下一轮 “事件循环” 开始时执行， <code>Promise.resolve()</code> 在本轮 “事件循环” 结束时执行， <code>console.log('one')</code> 则是立即执行，因此最先输出</p></li></ol><h3><span id="promisereject">Promise.reject()</span></h3><blockquote><p><code>Promise.reject(reason)</code> 方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为 <code>rejected</code></p></blockquote><p>注意：<code>Promise.reject()</code> 方法的参数，会原封不动地作为 <code>reject</code> 的理由，变成后续方法的参数。这一点与 <code>Promise.resolve</code> 方法不一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject</code> 方法的参数是一个 <code>thenable</code> 对象，执行以后，后面 <code>catch</code> 方法的参数不是 <code>reject</code> 抛出的 <em>“出错了”</em> 这个字符串，而是 <code>thenable</code> 对象。</p><h3><span id="附加方法">附加方法</span></h3><h4><span id="done"><code>done()</code></span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="built_in">Promise</span>.prototype.done || <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4><span id="finally"><code>finally()</code></span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="built_in">Promise</span>.prototype.finally || <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="iterator-和-forof-循环">✎ Iterator 和 for...of 循环</span></h2><h3><span id="iterator遍历器的概念">Iterator（遍历器）的概念</span></h3><blockquote><p>遍历器（<code>Iterator</code>）是一种接口，为各种不同的数据结构提供统一的访问机制。 任何数据结构只要部署 <code>Iterator</code> 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</p></blockquote><p><code>Iterator</code> 的作用：</p><ol><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，<code>Iterator</code> 接口主要供 <code>for...of</code> 消费</li></ol><h3><span id="默认-iterator-接口">默认 Iterator 接口</span></h3><ul><li><p>当使用 <code>for...of</code> 循环遍历某种数据结构时，该循环会自动去寻找 <code>Iterator</code> 接口。一种数据结构只要部署了 <code>Iterator</code> 接口，我们就称这种数据结构是 “可遍历的”（<code>iterable</code>）</p></li><li><p><code>ES6</code> 规定，默认的 <code>Iterator</code> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要具有 <code>Symbol.iterator</code> 属性，就可以认为是“可遍历的”（<code>iterable</code>）。<code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 <code>Symbol.iterator</code>，它是一个表达式，返回 <code>Symbol</code> 对象的 <code>iterator</code> 属性，这是一个预定义好的、类型为 <code>Symbol</code> 的特殊值，所以要放在方括号内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>凡是部署了 <code>Symbol.iterator</code> 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象</p></li><li><p>对于类似数组的对象（存在数值键名和 <code>length</code> 属性），部署 <code>Iterator</code> 接口，有一个简便方法，就是 <code>Symbol.iterator</code> 方法直接引用数组的 <code>Iterator</code> 接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="调用-iterator-接口的场合">调用 <code>Iterator</code> 接口的场合</span></h3><ul><li><p>解构赋值</p><p>对 <code>Array</code> 和 <code>Set</code> 结构进行解构赋值时，会默认调用 <code>Symbol.iterator</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">let</span> [x, y] = set; <span class="comment">// x='a'; y='b'</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str]; <span class="comment">// ['h','e','l','l','o']</span></span><br></pre></td></tr></table></figure></li><li><p><code>yield*</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>其他场合</p><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口：</p><ul><li><code>for...of</code></li><li><code>Array.from()</code></li><li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code></li><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li></ul></li></ul><h3><span id="遍历器对象的-returnthrow">遍历器对象的 <code>return()</code>，<code>throw()</code></span></h3><ul><li><p>遍历器对象除了具有 <code>next</code> 方法，还可以具有 <code>return</code> 方法和 <code>throw</code> 方法。如果你自己写遍历器对象生成函数，那么 <code>next</code> 方法是必须部署的，<code>return</code> 方法和 <code>throw</code> 方法是否部署是可选的</p></li><li><p><code>return</code> 方法的使用场合是：如果 <code>for...of</code> 循环提前退出（通常是因为出错，或者有 <code>break</code> 语句或 <code>continue</code> 语句），就会调用 <code>return</code> 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 <code>return</code> 方法。注意，<code>return</code> 方法<strong>必须返回一个对象</strong>，这是 <code>Generator</code> 规格决定的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">return</span>() &#123;</span><br><span class="line">      file.close();</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>throw</code> 方法主要是配合 <code>Generator</code> 函数使用，一般的遍历器对象用不到这个方法</p></li></ul><h3><span id="forof-循环"><code>for...of</code> 循环</span></h3><h4><span id="数组">数组</span></h4><ul><li><p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 <code>iterator</code> 接口，就可以用 <code>for...of</code> 循环遍历它的成员。也就是说，<code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法</p></li><li><p><code>for...of</code> 循环可以使用的范围包括 <code>Array</code>、<code>Set</code> 和 <code>Map</code> 结构、某些类似数组的对象（比如 <code>arguments</code> 对象、<code>DOM NodeList</code> 对象）、<code>Generator</code> 对象，以及 <code>字符串</code></p></li><li><p>与 <code>for...in</code> 的区别：</p><ul><li><code>for...in</code> 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 <code>for...of</code> 循环，允许遍历获得键值</li><li><code>for...of</code> 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  "3", "5", "7"， 不包含 'foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4><span id="字符串">字符串</span></h4><p>对于字符串来说，<code>for...of</code> 循环还有一个特点，就是会正确识别 32 位 <code>UTF-16</code> 字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">'a\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// '\uD83D\uDC0A'</span></span><br></pre></td></tr></table></figure><h2><span id="generator-函数的语法">✎ Generator 函数的语法</span></h2><h3><span id="简介">简介</span></h3><ol><li><code>Generator</code> 函数是 <code>ES6</code> 提供的一种异步编程解决方案</li><li><code>Generator</code> 函数是一个<em>状态机</em>，封装了多个内部状态</li><li><code>Generator</code> 函数执行后返回一个<em>遍历器对象</em>，也就是说，<code>Generator</code> 函数除了状态机，还是一个遍历器对象生成函数</li></ol><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*···*/</span> &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><p>调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。 以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象： <code>value</code> 属性表示当前的内部状态的值，是 <code>yield</code> 表达式后面那个表达式的值； <code>done</code> 属性是一个布尔值，表示是否遍历结束</p></blockquote><h3><span id="yield-表达式">yield 表达式</span></h3><ul><li><code>yield</code> 表达式 表示遍历器对象的暂停标识</li><li><code>yield</code> 表达式 如果用在另一个表达式之中，必须放在 <em>圆括号</em> 里面</li><li><code>yield</code> 表达式 本身没有返回值，或者说总是返回 <code>undefined</code></li><li>紧跟在 <code>yield</code> 后面的那个表达式的值，作为 <code>next()</code> 返回的对象的 <code>value</code> 属性值</li><li><code>return</code> 后表示遍历结束状态时，返回值作为遍历后 <code>value</code> 的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="与-iterator-接口的关系">与 Iterator 接口的关系</span></h3><blockquote><p>任意一个对象的 <code>Symbol.iterator</code> 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象</p></blockquote><p>由于 <code>Generator</code> 函数就是遍历器生成函数，因此可以把 <code>Generator</code> 赋值给对象的 <code>Symbol.iterator</code> 属性，从而使得该对象具有 <code>Iterator</code> 接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3><span id="next-方法的参数">next() 方法的参数</span></h3><blockquote><p><code>next</code> 方法可以带一个参数，该参数就会被当作 <strong>上一个</strong> <code>yield</code> 表达式的返回值</p></blockquote><p>注意： 由于 <code>next</code> 方法的参数表示 <strong>上一个</strong> <code>yield</code> 表达式的返回值，所以在 <strong>第一次</strong> 使用 <code>next</code> 方法时，传递参数是无效的。 从语义上讲，第一个 <code>next</code> 方法用来启动遍历器对象，所以不用带有参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><h3><span id="forof-循环">for...of 循环</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><p>上面代码使用 <code>for...of</code> 循环，依次显示 <strong>2</strong> 个 <code>yield</code> 表达式的值。 这里需要注意，一旦 <code>next</code> 方法的返回对象的 <code>done</code> 属性为 <code>true</code>，<code>for...of</code> 循环就会中止，且不包含该返回对象， 所以上面代码的 <code>return</code> 语句返回的 <code>3</code> 和之后的 <code>4</code>，不包括在 <code>for...of</code> 循环之中</p><blockquote><p>除了 <code>for...of</code> 循环以外，扩展运算符（<code>...</code>）、解构赋值和 <code>Array.from</code> 方法内部调用的，都是遍历器接口。 这意味着，它们都可以将 <code>Generator</code> 函数返回的 <code>Iterator</code> 对象，作为参数 <strong>自注</strong>： 一旦执行了 <code>next()</code> 之后，再进行遍历操作（解构赋值、扩展运算等）， 结果中将<strong>不包含</strong> <code>next()</code> 之前的返回结果，即从 <code>Generator</code> 对象当前的状态开始遍历</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = Gen();</span><br><span class="line"></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">[...g] <span class="comment">// [2, 3, 4]</span></span><br><span class="line">[...g] <span class="comment">// []</span></span><br></pre></td></tr></table></figure><blockquote><p><code>for...of</code> 的本质是一个 <code>while</code> 循环，所以上面的代码实质上执行的是下面的逻辑</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> it = iterateJobs(jobs);</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.done)&#123;</span><br><span class="line">  <span class="keyword">let</span> result = res.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="generatorprototypethrow">Generator.prototype.throw()</span></h3><ul><li><p><code>throw</code> 方法，可以在函数体<strong>外</strong>抛出错误，然后在 <code>Generator</code> 函数体<strong>内</strong>捕获</p></li><li><p><code>throw</code> 方法被捕获以后，会附带执行下一条 <code>yield</code> 表达式。也就是说，会附带执行一次 <code>next()</code> 方法</p></li><li><p>只要 <code>Generator</code> 函数内部部署了 <code>try...catch</code> 代码块，那么遍历器的 <code>throw</code> 方法抛出的错误，不影响下一次遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next(); <span class="comment">// a</span></span><br><span class="line">g.throw(); <span class="comment">// b</span></span><br><span class="line">g.next(); <span class="comment">// c</span></span><br></pre></td></tr></table></figure></li><li><p>一旦 <code>Generator</code> 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 <code>next()</code> 方法，将返回一个 <code>value</code> 属性等于 <code>undefined</code> 、<code>done</code> 属性等于 <code>true</code> 的对象，即 JavaScript 引擎认为这个 <code>Generator</code> 已经运行结束了</p></li></ul><h3><span id="generatorprototypereturn">Generator.prototype.return()</span></h3><blockquote><p><code>return</code> 方法，可以返回给定的值，并且终结遍历 <code>Generator</code> 函数</p></blockquote><p>如果 <code>Generator</code> 函数内部有 <code>try...finally</code> 代码块，那么 <code>return</code> 方法会推迟到 <code>finally</code> 代码块执行完再执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = numbers();</span><br><span class="line">g.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 <code>return</code> 方法后，就开始执行 <code>finally</code> 代码块，然后等到 <code>finally</code> 代码块执行完，再执行 <code>return</code> 方法</p><h3><span id="next-throw-return-的共同点">next()、throw()、return() 的共同点</span></h3><blockquote><p><code>next()</code>、<code>throw()</code>、<code>return()</code> 这三个方法本质上是同一件事，可以放在一起理解。 它们的作用都是让 <code>Generator</code> 函数<em>恢复执行</em>，并且使用不同的语句替换 <code>yield</code> 表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br><span class="line"></span><br><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error('出错了'))</span></span><br><span class="line"><span class="comment">// ;</span></span><br><span class="line"></span><br><span class="line">gen.return(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><h3><span id="yield-表达式">yield* 表达式</span></h3><blockquote><p><code>yield*</code> 表达式，用来在一个 <code>Generator</code> 函数里面执行另一个 <code>Generator</code> 函数</p></blockquote><ul><li><p>如果在 <code>Generator</code> 函数内部，调用另一个 <code>Generator</code> 函数，默认情况下是没有效果的</p></li><li><p>从语法角度看，如果 <code>yield</code> 表达式后面跟的是一个遍历器对象，需要在 <code>yield</code> 表达式后面加上<strong>星号</strong>，表明它返回的是一个遍历器对象。这被称为 <code>yield*</code> 表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure></li><li><p><code>yield*</code> 后面的 <code>Generator</code> 函数（没有 <code>return</code> 语句时），等同于在 <code>Generator</code> 函数内部，部署一个 <code>for...of</code> 循环反之，在有 <code>return</code> 语句时，则需要用 <code>var value = yield* iterator</code> 的形式获取 <code>return</code> 语句的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际上，任何数据结构只要有 <code>Iterator</code> 接口，就可以被 <code>yield*</code> 遍历</p></li></ul><h2><span id="generator-函数的异步调用">✎ Generator 函数的异步调用</span></h2><h3><span id="传统方法">传统方法</span></h3><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise 对象</li></ul><h3><span id="基本概念">基本概念</span></h3><blockquote><p>所谓&quot;异步&quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段， 先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着</p></blockquote><h3><span id="协程">协程</span></h3><blockquote><p>&quot;协程&quot;（<code>coroutine</code>），意思是多个线程互相协作，完成异步任务</p></blockquote><p>运行流程大致如下：</p><ol><li>协程 <code>A</code> 开始执行</li><li>协程 <code>A</code> 执行到一半，进入暂停，执行权转移到协程 <code>B</code></li><li>（一段时间后）协程 <code>B</code> 交还执行权</li><li>协程 <code>A</code> 恢复执行</li></ol><h3><span id="thunk-函数">Thunk 函数</span></h3><ul><li><p>编译器的 “传名调用” 实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <code>Thunk</code> 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure></li></ul><h3><span id="co-模块">co 模块</span></h3><ul><li><p>用于 <code>Generator</code> 函数的自动执行</p></li><li><p><code>co</code> 模块其实就是将两种自动执行器（<code>Thunk</code> 函数和 <code>Promise</code> 对象），包装成一个模块。使用 <code>co</code> 的前提条件是，<code>Generator</code> 函数的yield命令后面，只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象。如果数组或对象的成员，全部都是 <code>Promise</code> 对象，也可以使用 <code>co</code></p></li></ul><h2><span id="async-函数">✎ async 函数</span></h2><h3><span id="基本用法">基本用法</span></h3><blockquote><p><code>async</code> 函数返回一个 <code>Promise</code> 对象，可以使用 <code>then</code> 方法添加回调函数。 当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">val, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tm = <span class="keyword">await</span> timeout(delay);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'world'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;</span></span><br><span class="line"><span class="comment">// world // after 500ms</span></span><br></pre></td></tr></table></figure><h3><span id="语法">语法</span></h3><ul><li><p><code>async</code> 函数返回一个 <code>Promise</code> 对象</p></li><li><p><code>async</code> 函数内部 <code>return</code> 语句返回的值，会成为 <code>then</code> 方法回调函数的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure></li><li><p><code>async</code> 函数返回的 <code>Promise</code> 对象，必须等到内部所有 <code>await</code> 命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到 <code>return</code> 语句或者 <em>抛出错误</em> 。也就是说，只有 <code>async</code> 函数内部的异步操作执行完，才会执行 <code>then</code> 方法指定的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 <code>getTitle</code> 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 <code>then</code> 方法里面的 <code>console.log</code></p></li><li><p>正常情况下，<code>await</code> 命令后面是一个 <code>Promise</code> 对象。如果不是，会被转成一个立即 <code>resolve</code> 的 <code>Promise</code> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li><li><p>只要一个 <code>await</code> 语句后面的 <code>Promise</code> 变为 <code>reject</code>，那么整个 <code>async</code> 函数都会中断执行。（个人理解： <code>reject()</code> 改变了整个函数 <code>async</code> 返回的 <code>promise</code> 对象的状态（rejected），抛出了异常，从而中断函数体的继续执行）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法是，将第一个 <code>await</code> 放在 <code>try...catch</code> 里面，或用 <code>catch</code> 方法处理异常</p></li></ul><h3><span id="使用注意点">使用注意点</span></h3><ol><li><p><code>await</code> 命令后面的 <code>Promise</code> 对象，运行结果可能是 <code>rejected</code>，所以最好把 <code>await</code> 命令放在 <code>try...catch</code> 代码块中</p></li><li><p>多个 <code>await</code> 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 命令只能用在 <code>async</code> 函数之中，如果用在普通函数，就会报错</p></li></ol><h3><span id="async-函数的实现原理">async 函数的实现原理</span></h3><blockquote><p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 <code>async</code> 函数都可以写成上面的第二种形式，其中的 <code>spawn</code> 函数就是自动执行器</p><h2><span id="class-的基本语法">✎ Class 的基本语法</span></h2><h3><span id="基本语法">基本语法</span></h3><ol><li>类的方法都定义在 <code>prototype</code> 对象上面</li><li>类的内部所有定义的方法，都是<strong>不可枚举</strong>的（<code>non-enumerable</code>）</li><li>类和模块的内部，默认就是<strong>严格模式</strong>，所以不需要使用 <code>use strict</code> 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用</li></ol><h3><span id="constructor-方法">constructor 方法</span></h3><ul><li><p><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有 <code>constructor</code> 方法，如果没有显式定义，一个空的 <code>constructor</code> 方法会被默认添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类必须使用 <code>new</code> 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 <code>new</code> 也可以执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="不存在变量提升">不存在变量提升</span></h3><ul><li><p>类<strong>不存在</strong>变量提升（<code>hoist</code>），这一点与 <code>ES5</code> 完全不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="class-的静态方法">Class 的静态方法</span></h3><ul><li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为 “静态方法”。注意： 如果静态方法包含 <code>this</code> 关键字，这个 <code>this</code> 指的是<strong>类</strong>，而不是实例</p></li><li><p>静态方法可以与非静态方法重名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar () &#123;</span><br><span class="line">    <span class="keyword">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></li><li><p>父类的静态方法，可以被子类继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="class-的静态属性和实例属性">Class 的静态属性和实例属性</span></h3><ul><li><p><code>ES6</code> 明确规定，<code>Class</code> 内部只有<strong>静态方法</strong>，没有静态属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写法一 - 无效</span></span><br><span class="line">  prop: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写法二 - 无效</span></span><br><span class="line">  <span class="keyword">static</span> prop: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>; <span class="comment">// 有效</span></span><br><span class="line">Foo.prop; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="newtarget-属性">new.target 属性</span></h3><ul><li><p><code>new.target</code> 属性，该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数。如果构造函数不是通过 <code>new</code> 命令调用的，<code>new.target</code> 会返回 <code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的</p></li><li><p>子类继承父类时，<code>new.target</code> 会返回<strong>子类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name); <span class="comment">// Square</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="class-的继承">✎ Class 的继承</span></h2><h3><span id="简介">简介</span></h3><ul><li><p>子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，然后对其进行加工。如果不调用 <code>super</code> 方法，子类就得不到 <code>this</code> 对象</p></li><li><p><code>ES5</code> 的继承，实质是先创造<strong>子类</strong>的实例对象 <code>this</code>，然后再将<strong>父类</strong>的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。<code>ES6</code> 的继承机制完全不同，实质是先创造<strong>父类</strong>的实例对象 <code>this</code>（所以必须先调用 <code>super</code> 方法），然后再用子类的构造函数修改 <code>this</code></p></li><li><p>在子类的构造函数中，只有调用 <code>super()</code> 之后，才可以使用 <code>this</code> 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果子类没有定义 <code>constructor</code> 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 <code>constructor</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="super-关键字">super 关键字</span></h3><ul><li><p><code>super</code> 这个关键字，既可以当作函数使用，也可以当作对象使用：</p><ol><li><p><code>super</code> 作为<strong>函数</strong>调用时，代表父类的构造函数。<code>ES6</code> 要求，子类的构造函数必须执行一次 <code>super</code> 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A(); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B(); <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>注意，<code>super</code> 虽然代表了父类A的构造函数，但是返回的是子类B的实例， 即 <code>super</code> 内部的 <code>this</code> 指的是B，因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this)</code></p><blockquote><p>作为函数时，<code>super()</code> 只能用在<strong>子类</strong>的<strong>构造函数</strong>之中，用在其他地方就会报错</p></blockquote></li><li><p><code>super</code> 作为<strong>对象</strong>时，在普通方法中，指向父类的<strong>原型对象</strong>；在静态方法中，指向父类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>注意，使用 <code>super</code> 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li></ul><h3><span id="类的-prototype-属性和-__proto__-属性">类的 <code>prototype</code> 属性和 <code>__proto__</code> 属性</span></h3><p>类的继承是按照下面的模式实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>可以这样理解：</p><ol><li>作为一个对象，子类（B）的原型（<code>__proto__</code>属性）是父类（A）；</li><li>作为一个构造函数，子类（B）的原型对象（<code>prototype</code> 属性）是父类的原型对象（<code>prototype</code> 属性）的实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure><h3><span id="原生构造函数的继承">原生构造函数的继承</span></h3><ul><li><p><code>ES6</code> 可以自定义原生数据结构（比如 <code>Array</code>、<code>String</code> 等）的子类，这是 <code>ES5</code> 无法做到的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意：继承 <code>Object</code> 的子类，有一个 <strong>行为差异</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewObj</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> NewObj(&#123;<span class="attr">attr</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">o.attr === <span class="literal">true</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>NewObj</code> 继承了 <code>Object</code>，但是无法通过 <code>super</code> 方法向父类 <code>Object</code> 传参。 这是因为 <code>ES6</code> 改变了 <code>Object</code> 构造函数的行为，一旦发现 <code>Object</code> 方法不是通过 <code>new Object()</code> 这种形式调用，<code>ES6</code> 规定 <code>Object</code> 构造函数会忽略参数</p></li></ul><h2><span id="decorator">✎ Decorator</span></h2><p><a href="//es6.ruanyifeng.com/#docs/decorator">提案</a></p><h2><span id="module-的语法">✎ Module 的语法</span></h2><h3><span id="概述">概述</span></h3><ul><li><p><code>ES6</code> 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>这种加载称为 “编译时加载” 或者 静态加载，即 <code>ES6</code> 可以在编译时就完成模块加载，效率要比 <code>CommonJS</code> 模块的加载方式高。 当然，这也导致了没法引用 <code>ES6</code> 模块本身，因为它不是对象</p></li><li><p><code>ES6</code> 模块的好处：</p><ul><li>静态加载，编译时就能确定模块的依赖关系，以及输入和输出的变量</li><li>不再需要 <code>UMD</code> 模块格式了，将来服务器和浏览器都会支持 <code>ES6</code> 模块格式。目前，通过各种工具库，其实已经做到了这一点</li><li>将来浏览器的新 <code>API</code> 就能用模块格式提供，不再必须做成全局变量或者 <code>navigator</code> 对象的属性</li><li>不再需要对象作为命名空间（比如 <code>Math</code> 对象），未来这些功能可以通过模块提供</li></ul></li></ul><h3><span id="严格模式">严格模式</span></h3><ul><li><p><code>ES6</code> 的模块自动采用严格模式，不管你有没有在模块头部加上 <code>&quot;use strict&quot;;</code></p></li><li><p><code>ES6</code> 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>，即不应该在顶层代码使用 <code>this</code></p></li><li><p><strong>严格模式</strong> 主要有以下限制：</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 <code>with</code> 语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用 <code>前缀 0</code> 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量 <code>delete variable</code>，会报错，只能删除属性 <code>delete global[prop]</code></li><li><code>eval</code> 不会在它的外层作用域引入变量</li><li><code>eval</code> 和 <code>arguments</code> 不能被重新赋值</li><li><code>arguments</code> 不会自动反映函数参数的变化</li><li>不能使用 <code>arguments.callee</code></li><li>不能使用 <code>arguments.caller</code></li><li>禁止 <code>this</code> 指向全局对象（<code>ES6</code> 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>，即不应该在顶层代码使用 <code>this</code>）</li><li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</li><li>增加了保留字（比如 <code>protected</code>、<code>static</code> 和 <code>interface</code>）</li></ul></li></ul><h3><span id="export-命令">export 命令</span></h3><ul><li><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量</p><blockquote><p><strong>注意</strong>： <code>export</code> 命令规定的是对外的<strong>接口</strong>，必须与模块内部的变量建立一一对应关系</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br></pre></td></tr></table></figure><p>上面两种写法都会报错，因为没有提供对外的接口。 第一种写法直接输出 <code>1</code>， 第二种写法通过变量 <code>m</code>，还是直接输出 <code>1</code>。 <code>1</code> 只是一个值，不是接口。正确的写法是下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><p>上面三种写法都是正确的，规定了对外的接口 <code>m</code>。其他脚本可以通过这个接口，取到值 <code>1</code>。 它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系</p></li><li><p><code>export</code> 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。即：<code>ES6</code> 模块输出的是值的<strong>引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量 <code>foo</code>，值为 <code>bar</code>，<code>500</code> 毫秒之后变成 <code>baz</code>。</p><p>这一点与 <code>CommonJS</code> 规范完全不同。<code>CommonJS</code> 模块输出的是值的缓存，不存在动态更新</p></li></ul><h3><span id="import-命令">import 命令</span></h3><ul><li><p><code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行。<code>import</code> 命令是编译阶段执行的，在代码运行之前</p></li><li><p>由于 <code>import</code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果多次重复执行同一句 <code>import</code> 语句，那么<strong>只会执行一次</strong>，而不会执行多次（<code>Singleton</code> 模式）</p></li></ul><h3><span id="模块的整体加载">模块的整体加载</span></h3><ul><li><p>用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象（上例是 <code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是<strong>不允许</strong>的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="export-default-命令">export default 命令</span></h3><ul><li><p><code>export default</code> 命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此 <code>export default</code> 命令只能使用<strong>一次</strong>所以，<code>import</code> 命令后面才不用加大括号，因为只可能对应一个方法</p></li><li><p>本质上，<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字（<code>export default</code> 本质是将该命令后面的值，赋给 <code>default</code> 变量以后再默认）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from 'modules';</span></span><br></pre></td></tr></table></figure><h2><span id="module-的加载实现">✎ Module 的加载实现</span></h2><h3><span id="浏览器加载">浏览器加载</span></h3><ul><li><p><code>defer</code> 是 “渲染完再执行”，<code>async</code> 是 “下载完就执行”</p><blockquote><p><code>defer</code> 要等到整个页面在内存中正常渲染结束（<code>DOM</code> 结构完全生成，以及其他脚本执行完成），才会执行 <code>async</code> 是一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染 如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载，而多个 <code>async</code> 脚本是不能保证加载顺序的</p></blockquote></li><li><p>浏览器加载 <code>ES6</code> 模块，也使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性</p></li><li><p>浏览器对于带有 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 <code>&lt;script&gt;</code> 标签的 <code>defer</code> 属性</p></li><li><p>对于<strong>外部</strong>的模块脚本，需要注意：</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见</li><li>模块脚本自动采用<strong>严格模式</strong>，不管有没有声明 <code>use strict;</code></li><li>模块之中，可以使用 <code>import</code> 命令加载其他模块（.js后缀<strong>不可</strong>省略，需要提供绝对 URL 或相对 URL），也可以使用 <code>export</code> 命令输出对外接口</li><li>模块之中，顶层的 <code>this</code> 关键字返回 <code>undefined</code>，而不是指向 <code>window</code>。也就是说，在模块顶层使用 <code>this</code> 关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次</li></ul></li></ul><h3><span id="es6-模块与-commonjs-模块的差异">ES6 模块与 CommonJS 模块的差异</span></h3><h4><span id="对比">对比</span></h4><ul><li><code>CommonJS</code> 模块输出的是一个值的拷贝，<code>ES6</code> 模块输出的是值的引用</li><li><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口</li></ul><blockquote><p><code>ES6</code> 模块的运行机制与 <code>CommonJS</code> 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 <code>import</code>，就会生成一个<strong>只读引用</strong>。 等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 换句话说，<code>ES6</code> 的 <code>import</code> 有点像 <code>Unix</code> 系统的 “符号连接”，原始值变了，<code>import</code> 加载的值也会跟着变。 因此，<code>ES6</code> 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4><span id="commonjs-模块的加载原理">CommonJS 模块的加载原理</span></h4><blockquote><p><code>CommonJS</code> 的一个模块，就是一个脚本文件。<code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后需要用到这个模块的时候，就会到 <code>exports</code> 属性上面取值。 即使再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。 也就是说，<code>CommonJS</code> 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存</p><h3><span id="node-加载">Node 加载</span></h3><h4><span id="内部变量">内部变量</span></h4><blockquote><p><code>ES6</code> 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。 为了达到这个目标，<code>Node</code> 规定 <code>ES6</code> 模块之中不能使用 <code>CommonJS</code> 模块的特有的一些内部变量</p></blockquote><ul><li><p>首先，就是 <code>this</code> 关键字：</p><ul><li><code>ES6</code> 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code></li><li><code>CommonJS</code> 模块的顶层 <code>this</code> 指向当前模块</li></ul></li><li><p>其次，以下这些顶层变量在 <code>ES6</code> 模块之中都是<strong>不存在</strong>的：</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul></li></ul><h4><span id="es6-模块加载-commonjs-模块">ES6 模块加载 CommonJS 模块</span></h4><blockquote><p><code>CommonJS</code> 模块的输出都定义在 <code>module.exports</code> 这个属性上面。 <code>Node</code> 的 <code>import</code> 命令加载 <code>CommonJS</code> 模块，<code>Node</code> 会自动将 <code>module.exports</code> 属性，当作模块的默认输出，即等同于 <code>export default xxx</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">bar.default(); <span class="comment">// 2</span></span><br><span class="line">bar(); <span class="comment">// throws, bar is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>bar</code> 本身是一个对象，不能当作函数调用，只能通过 <code>bar.default</code> 调用</p><h4><span id="commonjs-模块加载-es6-模块">CommonJS 模块加载 ES6 模块</span></h4><blockquote><p><code>CommonJS</code> 模块加载 <code>ES6</code> 模块，不能使用 <code>require</code> 命令，而要使用 <code>import()</code> 函数。 <code>ES6</code> 模块的所有输出接口，会成为输入对象的属性</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = &#123; <span class="attr">bar</span>:<span class="string">'my-default'</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get f() &#123;return f;&#125;</span></span><br><span class="line"><span class="comment">//   get c() &#123;return c;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3><span id="循环加载">循环加载</span></h3><h4><span id="commonjs-模块的循环加载">CommonJS 模块的循环加载</span></h4><blockquote><p><code>CommonJS</code> 模块的重要特性是加载时执行，即脚本代码在 <code>require</code> 的时候，就会全部执行。 一旦出现某个模块被&quot;循环加载&quot;，就只输出已经执行的部分，还未执行的部分不会输出</p></blockquote><h4><span id="es6-模块的循环加载">ES6 模块的循环加载</span></h4><blockquote><p><code>ES6</code> 模块是动态引用，如果使用 <code>import</code> 从一个模块加载变量（即 <code>import foo from 'foo'</code>）， 那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</p></blockquote><h2><span id="编程风格">✎ 编程风格</span></h2><p><a href="//github.com/airbnb/javascript">Airbnb JavaScript 风格规范</a></p><h2><span id="读懂规格">✎ 读懂规格</span></h2><p><a href="//www.ecma-international.org/ecma-262/6.0/">ECMA 国际标准组织的官方网站</a></p><h2><span id="arraybuffer">✎ ArrayBuffer</span></h2><blockquote><p><code>ArrayBuffer</code> 对象、<code>TypedArray</code> 视图和 <code>DataView</code> 视图是 JavaScript 操作二进制数据的一个接口</p></blockquote><p>二进制数组由三类对象组成：</p><ol><li><p><code>ArrayBuffer</code> 对象：代表内存之中的一段二进制数据，可以通过 “视图” 进行操作。“视图” 部署了数组接口，这意味着，可以用数组的方法操作内存</p></li><li><p><code>TypedArray</code> 视图：共包括 9 种类型的视图，比如 <code>Uint8Array</code>（无符号 8 位整数）数组视图, <code>Int16Array</code>（16 位整数）数组视图, <code>Float32Array</code>（32 位浮点数）数组视图等等</p></li><li><p><code>DataView</code> 视图：可以自定义复合格式的视图，比如第一个字节是 <code>Uint8</code>（无符号 8 位整数）、第二、三个字节是 <code>Int16</code>（16 位整数）、第四个字节开始是 <code>Float32</code>（32 位浮点数）等等，此外还可以自定义字节序列</p></li></ol><p>简单说，<code>ArrayBuffer</code> 对象代表原始的二进制数据，<code>TypedArray</code> 视图用来读写简单类型的二进制数据，<code>DataView</code> 视图用来读写复杂类型的二进制数据。</p><blockquote><p>注意：二进制数组并不是真正的数组，而是类似数组的对象</p></blockquote><p>很多浏览器操作的 <code>API</code>，用到了二进制数组操作二进制数据，下面是其中的几个：</p><ul><li><code>File API</code></li><li><code>XMLHttpRequest</code></li><li><code>Fetch API</code></li><li><code>Canvas</code></li><li><code>WebSockets</code></li></ul><h2><span id="参考链接">✎ 参考链接</span></h2><p><a href="//es6.ruanyifeng.com/">ECMAScript 6 入门</a></p></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/assets/images/qrcode_subscribe.png" alt="晓月风尘 wechat" style="width:200px;max-width:100%"><div>扫描二维码与我相识</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>你我共同创造价值，记得支持一下哦~</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/assets/images/qrcode_donate_wechat.jpg" alt="晓月风尘 WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/assets/images/qrcode_donate_alipay.jpg" alt="晓月风尘 Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 晓月风尘</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.tiy.xyz/posts/2018/3526440553/" title="ECMAScript6 语法关键点">https://blog.tiy.xyz/posts/2018/3526440553/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">署名-非商业性使用-相同方式共享 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript/" rel="tag"># JavaScript</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/2018/2255145150/" rel="next" title="JavaScript 语言精粹：异步模型"><i class="fa fa-chevron-left"></i> JavaScript 语言精粹：异步模型</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/2018/3141220995/" rel="prev" title="从输入 URL 到页面加载完成的过程中都发生了什么事情？">从输入 URL 到页面加载完成的过程中都发生了什么事情？ <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/about/"><img class="site-author-image" itemprop="image" src="/assets/images/avatar.png" alt="晓月风尘"></a><p class="site-author-name" itemprop="name">晓月风尘</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/serif-x" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://weibo.com/serifx" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博 </a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/serifx" target="_blank" title="知乎"><i class="fa fa-fw fa-lightbulb-o"></i> 知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="//div.io/user/fouber" title="前端农民工" target="_blank">前端农民工</a></li><li class="links-of-blogroll-item"><a href="//www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">✎ 变量声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">✎ 变量的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.2.</span> <span class="nav-text">技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">✎ 字符串的扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">✎ 正则表达式的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">5.1.</span> <span class="nav-text">RegExp 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">5.2.</span> <span class="nav-text">u 修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">✎ 数值的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.1.</span> <span class="nav-text">Number.isFinite 和 Number.isNaN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.2.</span> <span class="nav-text">Number.parseInt 和 Number.parseFloat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.3.</span> <span class="nav-text">Number.isInteger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.4.</span> <span class="nav-text">Number.EPSILON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.5.</span> <span class="nav-text">Math.sign</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">✎ 函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">7.1.</span> <span class="nav-text">函数参数的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">7.2.</span> <span class="nav-text">函数的 length 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">7.3.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">7.4.</span> <span class="nav-text">尾调用优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">8.</span> <span class="nav-text">✎ 数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.1.</span> <span class="nav-text">扩展运算符的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.2.</span> <span class="nav-text">Array.from</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.3.</span> <span class="nav-text">Array.of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.4.</span> <span class="nav-text">copyWithin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.5.</span> <span class="nav-text">find() 和 findIndex()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.6.</span> <span class="nav-text">fill()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.7.</span> <span class="nav-text">entries()、keys() 和 values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.8.</span> <span class="nav-text">includes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">8.9.</span> <span class="nav-text">数组的空位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">9.</span> <span class="nav-text">✎ 对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">9.1.</span> <span class="nav-text">属性名表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">9.2.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">9.3.</span> <span class="nav-text">Object.assign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">9.4.</span> <span class="nav-text">属性的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">9.5.</span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">9.6.</span> <span class="nav-text">对象的扩展运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">9.6.1.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">9.6.2.</span> <span class="nav-text">扩展运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">10.</span> <span class="nav-text">✎ Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">10.2.</span> <span class="nav-text">作为属性名的 Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">10.3.</span> <span class="nav-text">属性名的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">10.4.</span> <span class="nav-text">Symbol.for()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">10.5.</span> <span class="nav-text">Symbol.keyFor()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">11.</span> <span class="nav-text">✎ Set 和 Map 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">11.1.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">11.2.</span> <span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">11.3.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">11.4.</span> <span class="nav-text">WeakMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">12.</span> <span class="nav-text">✎ Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">12.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">12.2.</span> <span class="nav-text">Proxy 实例的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">12.2.1.</span> <span class="nav-text">get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">12.2.2.</span> <span class="nav-text">this 问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">13.</span> <span class="nav-text">✎ Reflect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">13.1.</span> <span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">14.</span> <span class="nav-text">✎ Promise 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.1.</span> <span class="nav-text">Promise 的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.2.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.3.</span> <span class="nav-text">Promise.prototype.then()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.4.</span> <span class="nav-text">Promise.race()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.5.</span> <span class="nav-text">Promise.resolve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.6.</span> <span class="nav-text">Promise.reject()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">14.7.</span> <span class="nav-text">附加方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">14.7.1.</span> <span class="nav-text">done()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">14.7.2.</span> <span class="nav-text">finally()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">15.</span> <span class="nav-text">✎ Iterator 和 for...of 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">15.1.</span> <span class="nav-text">Iterator（遍历器）的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">15.2.</span> <span class="nav-text">默认 Iterator 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">15.3.</span> <span class="nav-text">调用 Iterator 接口的场合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">15.4.</span> <span class="nav-text">遍历器对象的 return()，throw()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">15.5.</span> <span class="nav-text">for...of 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">15.5.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">15.5.2.</span> <span class="nav-text">字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">16.</span> <span class="nav-text">✎ Generator 函数的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.2.</span> <span class="nav-text">yield 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.3.</span> <span class="nav-text">与 Iterator 接口的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.4.</span> <span class="nav-text">next() 方法的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.5.</span> <span class="nav-text">for...of 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.6.</span> <span class="nav-text">Generator.prototype.throw()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.7.</span> <span class="nav-text">Generator.prototype.return()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.8.</span> <span class="nav-text">next()、throw()、return() 的共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">16.9.</span> <span class="nav-text">yield* 表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">17.</span> <span class="nav-text">✎ Generator 函数的异步调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">17.1.</span> <span class="nav-text">传统方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">17.2.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">17.3.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">17.4.</span> <span class="nav-text">Thunk 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">17.5.</span> <span class="nav-text">co 模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">18.</span> <span class="nav-text">✎ async 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">18.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">18.2.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">18.3.</span> <span class="nav-text">使用注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">18.4.</span> <span class="nav-text">async 函数的实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">19.</span> <span class="nav-text">✎ Class 的基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">19.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">19.2.</span> <span class="nav-text">constructor 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">19.3.</span> <span class="nav-text">不存在变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">19.4.</span> <span class="nav-text">Class 的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">19.5.</span> <span class="nav-text">Class 的静态属性和实例属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">19.6.</span> <span class="nav-text">new.target 属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">20.</span> <span class="nav-text">✎ Class 的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">20.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">20.2.</span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">20.3.</span> <span class="nav-text">类的 prototype 属性和 __proto__ 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">20.4.</span> <span class="nav-text">原生构造函数的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">21.</span> <span class="nav-text">✎ Decorator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">22.</span> <span class="nav-text">✎ Module 的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">22.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">22.2.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">22.3.</span> <span class="nav-text">export 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">22.4.</span> <span class="nav-text">import 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">22.5.</span> <span class="nav-text">模块的整体加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">22.6.</span> <span class="nav-text">export default 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">23.</span> <span class="nav-text">✎ Module 的加载实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">23.1.</span> <span class="nav-text">浏览器加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">23.2.</span> <span class="nav-text">ES6 模块与 CommonJS 模块的差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.2.1.</span> <span class="nav-text">对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.2.2.</span> <span class="nav-text">CommonJS 模块的加载原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">23.3.</span> <span class="nav-text">Node 加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.3.1.</span> <span class="nav-text">内部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.3.2.</span> <span class="nav-text">ES6 模块加载 CommonJS 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.3.3.</span> <span class="nav-text">CommonJS 模块加载 ES6 模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">23.4.</span> <span class="nav-text">循环加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.4.1.</span> <span class="nav-text">CommonJS 模块的循环加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">23.4.2.</span> <span class="nav-text">ES6 模块的循环加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">24.</span> <span class="nav-text">✎ 编程风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">25.</span> <span class="nav-text">✎ 读懂规格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">26.</span> <span class="nav-text">✎ ArrayBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">27.</span> <span class="nav-text">✎ 参考链接</span></a></li></ol></div></div></section></div></aside><script>var cloudTieConfig={url:document.location.href,sourceId:"",productKey:"79a00ad3622440e3b78e418eb9ccb914",target:"cloud-tie-wrapper"}</script><script src="//img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 - <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">晓月风尘</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.3/velocity.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.3/velocity.ui.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("kY8gaNK6X2CFKk3ejCjLSmFr-gzGzoHsz","q0C2fuiURtcWbd97195g4FTi")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/javascript" src="/assets/js/src/exturl.js?v=5.1.0"></script></body></html>